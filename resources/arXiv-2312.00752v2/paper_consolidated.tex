\documentclass{article} %
\usepackage{etoolbox}       %

\usepackage{amsmath,amsthm}   %
\usepackage{mathtools}  %
\usepackage[dvipsnames]{xcolor}         %

\newtoggle{arxiv}
\toggletrue{arxiv}
\iftoggle{arxiv}{
  \usepackage[parfill]{parskip}
  \usepackage[citestyle=authoryear-comp,sorting=nyt,maxbibnames=99,backend=biber]{biblatex}
  \newcommand{\citep}{\parencite}
  \newcommand{\citet}{\textcite}
  \addbibresource{biblio.bib}  %

  \setlength{\textwidth}{6.8in}  %
  \setlength{\textheight}{9in}
  \setlength{\oddsidemargin}{0in}
  \setlength{\evensidemargin}{0in}
  \setlength{\topmargin}{-0.5in}
  \newlength{\defbaselineskip}
  \setlength{\defbaselineskip}{\baselineskip}
  \setlength{\marginparwidth}{0.8in}
  \setlength{\parskip}{6pt}%
  \setlength{\parindent}{0pt}%

  \RequirePackage[T1]{fontenc}
  \RequirePackage[tt=false, type1=true]{libertine}
  \RequirePackage[varqu]{zi4}
  \RequirePackage[libertine]{newtxmath}

}{
  \usepackage{amsfonts}       %
\usepackage{colm2024_conference}
  \addtolength{\tabcolsep}{-3pt} %
  \def\setstretch#1{\renewcommand{\baselinestretch}{#1}}
  \setstretch{0.98}
  \addtolength{\parskip}{-1pt}

  \usepackage[compact]{titlesec}
  \titlespacing{\section}{0pt}{*1}{*0}
  \titlespacing{\subsection}{0pt}{*1}{*0}
  \usepackage[subtle, mathdisplays=tight, charwidths=tight, leading=normal]{savetrees}
  \addtolength\textfloatsep{-0.5em}
  \addtolength\intextsep{-0.2em}
\bibliographystyle{colm2024_conference}
}


\usepackage{bm}
\usepackage{bbm}

\usepackage{booktabs}       %
\usepackage{nicefrac}       %
\usepackage{microtype}      %
\usepackage{multirow}
\usepackage[inline]{enumitem}
\usepackage{diagbox}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[font=small]{caption} %
\usepackage{algorithm,algorithmicx,algpseudocode} %
\usepackage{subcaption}

\usepackage{url}
\usepackage{hyperref}
\hypersetup{
     colorlinks   = true,
     linkcolor    = blue,
     citecolor    = magenta,
     urlcolor     = red,
     pdfborderstyle={/S/U/W 1},
}

\usepackage[capitalise,noabbrev]{cleveref}  %


\usepackage{pifont}%
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%



\newtheorem{theorem}{Theorem}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}[lemma]{Corollary}
\newtheorem{observation}[lemma]{Observation}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}{Definition}
\newtheorem{remark}[lemma]{Remark}
\newtheorem{claim}{Claim}

\newcommand{\paren}[1]{\left (#1 \right)}
\newcommand{\dd}{\mathop{}\!d}
\DeclareMathOperator*{\diag}{diag}
\newcommand{\NAME}{Mamba}

\newcommand{\R}{\mathbb{R}}
\newcommand{\dt}{\Delta}
\newcommand{\A}{\bm{A}}
\newcommand{\B}{\bm{B}}
\newcommand{\C}{\bm{C}}
\newcommand{\D}{\bm{D}}
\newcommand{\K}{\overline{\bm{K}}}

\newcommand{\da}{\overline{\bm{A}}}
\newcommand{\db}{\overline{\bm{B}}}
\newcommand{\dA}{\overline{\bm{A}}}
\newcommand{\dB}{\overline{\bm{B}}}

\newcommand{\AB}{(\A, \B)}
\newcommand{\ABC}{(\A, \B, \C)}
\newcommand{\dtAB}{(\dt, \A, \B)}
\newcommand{\dtABC}{(\dt, \A, \B, \C)}
\newcommand{\dAB}{(\dA, \dB)}


\newcommand{\para}[1]{\iftoggle{arxiv}{\paragraph{#1}}{\textbf{#1}}}
\newcommand{\maybe}[1]{\textcolor{blue}{#1}}

\newcommand*\samethanks[1][\value{footnote}]{\footnotemark[#1]}
\iftoggle{arxiv}{
  \title{Mamba: Linear-Time Sequence Modeling with Selective State Spaces}
  \usepackage{authblk}
  \author[$^1$]{Albert Gu\thanks{Alphabetical by first name.}}
  \author[$^2$]{Tri Dao\samethanks}
  \affil[$^1$]{Machine Learning Department, Carnegie Mellon University}
  \affil[$^2$]{Department of Computer Science, Princeton University}
  \affil[ ]{{\texttt{agu@cs.cmu.edu}}, {\texttt{tri@tridao.me}}}
  \date{}
}{
  \title{Linear-Time Sequence Modeling with Selective State Spaces}
}


\begin{document}


\maketitle


% ========== BEGIN CONTENT FROM src/abstract.tex ==========
\begin{abstract}

  \noindent
  Foundation models, now powering most of the exciting applications in deep learning, are almost universally based on the Transformer architecture and its core attention module. 
  Many subquadratic-time architectures such as linear attention, gated convolution and recurrent models, and structured state space models (SSMs) have been developed to address Transformers' computational inefficiency on long sequences, but they have not performed as well as attention on important modalities such as language.  
  We identify that a key weakness of such models is their inability to perform content-based reasoning, and make several improvements.
  First, simply letting the SSM parameters be functions of the input addresses their weakness with discrete modalities, allowing the model to \emph{selectively} propagate or forget information along the sequence length dimension depending on the current token.
  Second, even though this change prevents the use of efficient convolutions, we design a hardware-aware parallel algorithm in recurrent mode.
  We integrate these selective SSMs into a simplified end-to-end neural network architecture without attention or even MLP blocks (\textbf{Mamba}).
  Mamba enjoys fast inference (5$\times$ higher throughput than Transformers) and linear scaling in sequence length, and its performance improves on real data up to million-length sequences.
  As a general sequence model backbone, Mamba achieves state-of-the-art performance across several modalities such as language, audio, and genomics. %
  On language modeling, our Mamba-3B model outperforms Transformers of the same size and matches Transformers twice its size, both in pretraining and downstream evaluation.
\end{abstract}

% ========== END CONTENT FROM src/abstract.tex ==========



% ========== BEGIN CONTENT FROM src/intro.tex ==========
\section{Introduction}
\label{sec:intro}

Foundation models (FMs), or large models pretrained on massive data then adapted for downstream tasks, have emerged as an effective paradigm in modern machine learning.
The backbone of these FMs are often
\emph{sequence models}, operating on arbitrary sequences of inputs from a wide variety of domains such as language, images, speech, audio, time series, and genomics
\citep{sutskever2014sequence,dosovitskiy2020image,oord2016wavenet,brown2020language,ismail2019deep,poli2023hyena}.
While this concept is agnostic to a particular choice of model architecture,
modern FMs are predominantly based on a single type of sequence model: the Transformer~\citep{vaswani2017attention} and its core attention layer\iftoggle{arxiv}{~\citep{bahdanau2015neural}}.
The efficacy of self-attention is attributed to its ability to route information densely within a context window, allowing it to model complex data.
However, this property brings fundamental drawbacks: an inability to model anything outside of a finite window,
and quadratic scaling with respect to the window length.
An enormous body of research has appeared on more efficient variants of attention to overcome these drawbacks~\citep{tay2022efficient},
but often at the expense of the very properties that makes it effective.
As of yet, none of these variants have been shown to be empirically effective at scale across domains.

Recently, structured state space sequence models (SSMs)~\citep{gu2021combining,gu2022efficiently} have emerged as a promising class of architectures for sequence modeling.
These models can be interpreted as a combination of recurrent neural networks (RNNs) and convolutional neural networks (CNNs), with inspiration from classical state space models \citep{kalman1960new}.
This class of models can be computed very efficiently as either a recurrence or convolution, with linear or near-linear scaling in sequence length.
Additionally, they have principled mechanisms for modeling long-range dependencies~\citep{gu2020hippo} in certain data modalities, and have dominated benchmarks such as the Long Range Arena~\citep{tay2021long}.
Many flavors of SSMs ~\citep{gu2022efficiently,gupta2022diagonal,gu2022parameterization,li2023makes,ma2023mega,smith2023s5,orvieto2023resurrecting}
have been successful in domains involving continuous signal data such as audio and vision~\citep{goel2022raw,saon2023diagonal,nguyen2022s4nd}.
However, they have been less effective at modeling discrete and information-dense data such as text.

%

%

We propose a new class of \textbf{selective state space models},
that improves on prior work on several axes to achieve the modeling power of Transformers while scaling linearly in sequence length.
%

\para{Selection Mechanism.}
First, we identify a key limitation of prior models: the ability to efficiently \emph{select} data in an input-dependent manner (i.e.\ focus on or ignore particular inputs).
Building on intuition based on important synthetic tasks such as selective copy and induction heads, we design a simple selection mechanism by parameterizing the SSM parameters based on the input.
This allows the model to filter out irrelevant information and remember relevant information indefinitely.

\para{Hardware-aware Algorithm.} This simple change poses a technical challenge for the computation of the model; in fact, all prior SSMs models must be time- and input-invariant in order to be computationally efficient.
We overcome this with a hardware-aware algorithm that computes the model recurrently with a scan instead of convolution, but does not materialize the expanded state in order to avoid IO access between different levels of the GPU memory hierarchy.
The resulting implementation is faster than previous methods both in theory (scaling linearly in sequence length, compared to pseudo-linear for all convolution-based SSMs) and on modern hardware (up to 3$\times$ faster on A100 GPUs).

\para{Architecture.}
We simplify prior deep sequence model architectures by combining the design of prior SSM architectures \citep{dao2023hungry} with the MLP block of Transformers into a single block, leading to a simple and homogenous architecture design (\textbf{Mamba}) incorporating selective state spaces.



%

Selective SSMs, and by extension the Mamba architecture, are fully recurrent models with key properties that make them suitable as the backbone of general foundation models operating on sequences.
\begin{enumerate*}[label=(\roman*)]
\item High quality: selectivity brings strong performance on dense modalities such as language and genomics.
\item Fast training and inference: computation and memory scales linearly in sequence length during training, and unrolling the model autoregressively during inference requires only constant time per step since it does not require a cache of previous elements.
\item Long context: the quality and efficiency together yield performance improvements on real data up to sequence length 1M.
\end{enumerate*}

%

We empirically validate Mamba's potential as a general sequence FM backbone, in both pretraining quality and domain-specific task performance, on several types of modalities and settings:
\begin{itemize}[leftmargin=*,itemsep=0pt,topsep=0pt]
  \item \textbf{Synthetics.} On important synthetic tasks such as copying and induction heads that have been proposed as being key to large language models, Mamba not only solves them easily but can \emph{extrapolate solutions indefinitely long} ($>$1M tokens).
  \item \textbf{Audio and Genomics.} Mamba out-performs prior state-of-the-art models such as SaShiMi, Hyena, and Transformers on modeling audio waveforms and DNA sequences, both in pretraining quality and downstream metrics (e.g. reducing FID on a challenging speech generation dataset by more than half). In both settings, its \emph{performance improves with longer context up to million-length sequences}.
  \item \textbf{Language Modeling.} Mamba is the first \emph{linear-time sequence model that truly achieves Transformer-quality performance}, both in pretraining perplexity and downstream evaluations.
    With scaling laws up to 1B parameters, we show that Mamba exceeds the performance of a large range of baselines, including very strong modern Transformer training recipes based on LLaMa~\citep{touvron2023llama}.
    Our Mamba language model has 5$\times$ generation throughput compared to Transformers of similar size, and Mamba-3B's quality matches that of Transformers twice its size (e.g.\ 4 points higher avg.\ on common sense reasoning compared to Pythia-3B and even exceeding Pythia-7B).
\end{itemize}
\iftoggle{arxiv}{
Model code and pre-trained checkpoints are open-sourced at \url{https://github.com/state-spaces/mamba}.
}{}


% ========== END CONTENT FROM src/intro.tex ==========



% ========== BEGIN CONTENT FROM src/background.tex ==========
\iftoggle{arxiv}{
  \begin{figure}[!t]
  \begin{center}
    \includegraphics[width=\linewidth]{fig/selection.pdf}
  \end{center}
  \caption{
  (\textbf{Overview}.)
  Structured SSMs independently map each channel (e.g. $D=5$) of an input $x$ to output $y$ through a higher dimensional latent state $h$ (e.g.\ $N=4$).
  Prior SSMs avoid materializing this large effective state ($DN$, times batch size $B$ and sequence length $L$) through clever alternate computation paths requiring
  time-invariance: the $(\dt, \A, \B, \C)$ parameters are constant across time.
  Our selection mechanism adds back input-dependent dynamics, which
  also requires a careful hardware-aware algorithm to only materialize the expanded states in more efficient levels of the GPU memory hierarchy.
}
  \label{fig:selection}
\end{figure}
}{}


\section{State Space Models}
\label{sec:background}



Structured state space sequence models (S4) are a recent class of sequence models for deep learning that are broadly related to RNNs, and CNNs,
and classical state space models.
They are inspired by a particular continuous system \eqref{eq:ssm}
that maps a 1-dimensional function or sequence $x(t) \in \R \mapsto y(t) \in \R$ through an implicit latent state \( h(t) \in \R^N \). %
\iftoggle{arxiv}{

}{}
Concretely,
S4 models are defined with four parameters $(\dt, \A, \B, \C)$, which define a sequence-to-sequence transformation in two stages.

\begin{minipage}[t]{.30\linewidth}
  \begin{subequations}
    \label{eq:ssm}
    \begin{align}
      h'(t) &= \A h(t) + \B x(t) \\
      y(t) &= \C h(t)
    \end{align}
  \end{subequations}
\end{minipage}%
\begin{minipage}[t]{.30\linewidth}
  \begin{subequations}
    \label{eq:ssm:recurrence}
    \begin{align}
    \label{eq:ssm:recurrence:1}
      h_{t} &= \dA h_{t-1} + \dB x_t \\
    \label{eq:ssm:recurrence:2}
      y_t &= \C h_t
    \end{align}
  \end{subequations}
\end{minipage}%
\begin{minipage}[t]{.39\linewidth}
  \begin{subequations}%
    \label{eq:ssm:convolution}
    \begin{align}
      \label{eq:ssm:convolution:1}
      \bm{\overline{K}} &= (\bm{C}\bm{\overline{B}}, \bm{C}\bm{\overline{A}}\bm{\overline{B}}, \dots, \bm{C}\bm{\overline{A}}^{k}\bm{\overline{B}}, \dots) \\
      \label{eq:ssm:convolution:2}
      y &= x \ast \bm{\overline{K}}
    \end{align}
  \end{subequations}
\end{minipage}

\para{Discretization.}
The first stage transforms the ``continuous parameters'' $\dtAB$ to ``discrete parameters'' $\dAB$ through fixed formulas $\dA = f_A(\dt, \A)$ and $\dB = f_B(\dt, \A, \B)$,
where the pair $(f_A, f_B)$ is called a \emph{discretization rule}.
\iftoggle{arxiv}{
  Various rules can be used such as the zero-order hold (ZOH) defined in equation \eqref{eq:zoh}.
  \begin{equation}
    \label{eq:zoh}
    \dA = \exp(\dt \bm{A})
    \qquad
    \dB = (\dt \bm{A})^{-1} (\exp(\dt \bm{A}) - \bm{I}) \cdot \dt \bm{B}
  \end{equation}
}{
  The most common is zero-order hold (ZOH) defined by
  $\dA = \exp(\dt \bm{A})$
  and $\dB = (\dt \bm{A})^{-1} (\exp(\dt \bm{A}) - \bm{I}) \cdot \dt \bm{B}$.
}

Discretization has deep connections to continuous-time systems which can endow them with additional properties such as resolution invariance \citep{nguyen2022s4nd} and automatically ensuring that the model is properly normalized \citep{gu2023train,orvieto2023resurrecting}.
It also has connections to gating mechanisms of RNNs \citep{tallec2018can,gu2020improving} which we will revisit in \cref{sec:method:properties}.
However, from a mechanical point of view discretization can simply be viewed as the first step of the computation graph in the forward pass of an SSM.
\iftoggle{arxiv}{
  Alternate flavors of SSMs can bypass the discretization step and parameterize $\dAB$ directly instead~\citep{zhang2023effectively}, which may be easier to reason about.
}{}


\para{Computation.}
After the parameters have been transformed from $(\dt, \A, \B, \C) \mapsto (\dA, \dB, \C)$,
the model can be computed in two ways, either as a \textbf{linear recurrence} \eqref{eq:ssm:recurrence} or a \textbf{global convolution} \eqref{eq:ssm:convolution}.

Commonly, the model uses the convolutional mode \eqref{eq:ssm:convolution} for efficient parallelizable training (where the whole input sequence is seen ahead of time), %
and switched into recurrent mode \eqref{eq:ssm:recurrence} for efficient autoregressive inference (where the inputs are seen one timestep at a time).


\para{Linear Time Invariance (LTI).}
An important property of equations \eqref{eq:ssm} to \eqref{eq:ssm:convolution} is that the model's dynamics are constant through time.
In other words $\dtABC$, and consequently $\dAB$ as well, are fixed for all time-steps.
This property is called \emph{linear time invariance (LTI)}, which is deeply connected to recurrence and convolutions.
Informally, we think of LTI SSMs as being equivalent to any linear recurrence \eqref{eq:ssm:recurrence:1} or convolution \eqref{eq:ssm:convolution:2},
and use LTI as an umbrella term for these classes of models.

Thus far, all structured SSMs have been LTI (e.g.\ computed as convolutions) because of fundamental efficiency constraints, discussed in \cref{sec:method:scan}.
However, a core insight of this work is that LTI models have fundamental limitations in modeling certain types of data,
and our technical contributions involve removing the LTI constraint while overcoming the efficiency bottlenecks.


\para{Structure and Dimensions.}
Finally, we note that structured SSMs are so named because computing them efficiently also requires imposing structure on the $\A$ matrix.
The most popular form of structure is diagonal \citep{gupta2022diagonal,gu2022parameterization,smith2023s5}, which we also use.

In this case, the $\A \in \R^{N \times N}, \B \in \R^{N \times 1}, \C \in \R^{1 \times N}$ matrices can all be represented by $N$ numbers.
To operate over an input sequence $x$ of batch size $B$ and length $L$ with $D$ channels,
the SSM is applied independently to each channel.
Note that in this case, the total hidden state has dimension $DN$ per input, and computing it over the sequence length requires $O(BLDN)$ time and memory; this is the root of the fundamental efficiency bottleneck addressed in \cref{sec:method:scan}.

\iftoggle{arxiv}{
\para{General State Space Models.}
We note that the term \emph{state space model} has a very broad meaning which simply represents the notion of any recurrent process with a latent state.
It has been used to refer to many disparate concepts in different disciplines,
including Markov decision processes (MDP) (reinforcement learning~\citep{hafner2020dream}),
dynamic causal modeling (DCM) (computational neuroscience~\citep{friston2003dynamic}),
Kalman filters (controls~\citep{kalman1960new}),
hidden Markov models (HMM) and linear dynamical systems (LDS) (machine learning),
and recurrent (and sometimes convolutional) models at large (deep learning).


Throughout this entire paper we use the term ``SSM'' to refer exclusively to the class of structured SSMs or S4 models \citep{gu2022efficiently,gupta2022diagonal,gu2022parameterization,ma2023mega,smith2023s5,hasani2023liquid} and use these terms interchangeably.
For convenience we may also include derivatives of such models, such as those focusing on either the linear-recurrence or global-convolution viewpoints \citep{orvieto2023resurrecting,li2023makes,poli2023hyena}, and clarify nuances when necessary.
}{}

\para{SSM Architectures.}
SSMs are standalone sequence transformations that can be incorporated into end-to-end neural network architectures.
\iftoggle{arxiv}{
(We also sometimes call SSM architectures SSNNs, which are to SSM layers as CNNs are to linear convolution layers.)
}{}
We discuss some of the most well-known SSM architectures, many of which will also serve as our primary baselines.
\iftoggle{arxiv}{
\begin{itemize}[leftmargin=*]
}{
\begin{itemize}[leftmargin=*,itemsep=0pt,topsep=0pt]
}
  \item Linear attention~\citep{katharopoulos2020transformers} is an approximation of self-attention involving a recurrence which can be viewed as a degenerate linear SSM.
  \item H3~\citep{dao2023hungry} generalized this recurrence to use S4; it can be viewed as an architecture with an SSM sandwiched by two gated connections (\cref{fig:architecture}).
    H3 also inserts a standard local convolution, which they frame as a shift-SSM, before the main SSM layer.
  \item Hyena~\citep{poli2023hyena} uses the same architecture as H3 but replaces the S4 layer with an MLP-parameterized global convolution~\citep{romero2021ckconv}. %
    \iftoggle{arxiv}{
  \item RetNet~\citep{sun2023retentive} adds an additional gate to the architecture and uses a simpler SSM, allowing an alternative parallelizable computation path, using a variant of multi-head attention (MHA) instead of convolutions.
    \item RWKV~\citep{peng2023rwkv} is a recent RNN designed for language modeling based on another linear attention approximation, the attention-free Transformer~\citep{zhai2021attention}. Its main ``WKV'' mechanism involves LTI recurrences and can be viewed as the ratio of two SSMs.
    }{}
\end{itemize}
Other closely related SSMs and architectures are discussed further in an extended related work (\cref{sec:related}).
We highlight in particular S5~\citep{smith2023s5}, QRNN~\citep{bradbury2016quasi},
and SRU~\citep{lei2017simple},
which we view as the most closely related methods to our core selective SSM.

%




% ========== END CONTENT FROM src/background.tex ==========



% ========== BEGIN CONTENT FROM src/method.tex ==========


\section{Selective State Space Models}
\label{sec:method}

We motivate our selection mechanism using intuition from synthetic tasks (\cref{sec:method:motivation}), then explain how to incorporate this mechanism into state space models (\cref{sec:method:selective}).
The resulting time-varying SSMs cannot use convolutions, presenting a technical challenge of how to compute them efficiently.
We overcome this with a hardware-aware algorithm that exploits the memory hierarchy on modern hardware (\cref{sec:method:scan}).
We then describe a simple SSM architecture without attention or even MLP blocks (\cref{sec:method:architecture}).
Finally, we discuss some additional properties of selection mechanisms (\cref{sec:method:properties}).

\subsection{Motivation: Selection as a Means of Compression}
\label{sec:method:motivation}

We argue that a fundamental problem of sequence modeling is \emph{compressing context into a smaller state}.
In fact, we can view the tradeoffs of popular sequence models from this point of view.
For example, attention is both effective and inefficient because it explicitly does not compress context at all.
This can be seen from the fact that autoregressive inference requires explicitly storing the entire context (i.e.\ the KV cache), which directly causes the slow linear-time inference and quadratic-time training of Transformers.
On the other hand, recurrent models are efficient because they have a finite state, implying constant-time inference and linear-time training.
However, their effectiveness is limited by how well this state has compressed the context.

To understand this principle,
we focus on two running examples of synthetic tasks (\cref{fig:copying}).
\begin{itemize}[leftmargin=*,itemsep=0pt,topsep=0pt]
  \item The \textbf{Selective Copying} task modifies the popular Copying task \citep{arjovsky2016unitary} by varying the position of the tokens to memorize. It requires \emph{content-aware} reasoning to be able to memorize the relevant tokens (\emph{colored}) and filter out the irrelevant ones (\emph{white}).
  \item The \textbf{Induction Heads} task is a well-known mechanism hypothesized to explain the majority of in-context learning abilities of LLMs~\citep{olsson2022context}. It requires \emph{context-aware} reasoning to know when to produce the correct output in the appropriate context (\emph{black}).
\end{itemize}

These tasks reveal the failure mode of LTI models. From the recurrent view, their constant dynamics (e.g.\ the $\dAB$ transitions in \eqref{eq:ssm:recurrence}) cannot let them select the correct information from their context, or affect the hidden state passed along the sequence in an input-dependent way.
From the convolutional view, it is known that global convolutions can solve the vanilla Copying task \citep{romero2021ckconv} because it only requires time-awareness, but that they have difficulty with the Selective Copying task because of lack of content-awareness (\cref{fig:copying}).
More concretely, the spacing between inputs-to-outputs is varying and cannot be modeled by static convolution kernels.

In summary, the efficiency vs.\ effectiveness tradeoff of sequence models is characterized by how well they compress their state:
efficient models must have a small state, while effective models must have a state that contains all necessary information from the context.
In turn, we propose that a fundamental principle for building sequence models is
\textbf{selectivity}: or the context-aware ability to focus on or filter out inputs into a sequential state.
In particular, a selection mechanism controls how information propagates or interacts along the sequence dimension (see \cref{sec:method:properties} for more discussion).

%

%

%

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\linewidth]{fig/copying.pdf}
  \caption{
    (\textit{Left}) The standard version of the Copying task involves constant spacing between input and output elements and is easily solved by time-invariant models such as linear recurrences and global convolutions.
    (\textit{Right Top}) The Selective Copying task has random spacing in between inputs and requires time-varying models that can \textit{selectively} remember or ignore inputs depending on their content.
    (\textit{Right Bottom}) The Induction Heads task is an example of associative recall that requires retrieving an answer based on context, a key ability for LLMs.
  }
  \label{fig:copying}
  \iftoggle{arxiv}{}{\vspace{-1em}}
\end{figure*}


\subsection{Improving SSMs with Selection}
\label{sec:method:selective}


One method of incorporating a selection mechanism into models is by letting their parameters that affect interactions along the sequence (e.g.\ the recurrent dynamics of an RNN or the convolution kernel of a CNN) be input-dependent.

\cref{alg:s4,alg:s6} illustrates the main selection mechanism that we use. %
The main difference is simply making several parameters $\dt, \B, \C$ functions of the input, %
along with the associated changes to tensor shapes throughout.
In particular, we highlight that these parameters now have a length dimension $L$,
meaning that the model has changed from time-invariant to time-varying.
(Note that shape annotations were described in \cref{sec:background}.)
This loses the equivalence to convolutions~\eqref{eq:ssm:convolution} with implications for its efficiency, discussed next. %

We specifically choose $s_B(x) = \mathsf{Linear}_N(x)$, $s_C(x) = \mathsf{Linear}_N(x)$,
$s_\dt(x) = \mathsf{Broadcast}_D(\mathsf{Linear}_1(x))$, and $\tau_\dt = \mathsf{softplus}$,
where $\mathsf{Linear}_d$ is a parameterized projection to dimension $d$.
The choice of $s_\dt$ and $\tau_\dt$ is due to a connection to RNN gating mechanisms explained in \cref{sec:method:properties}.


\begin{figure*}[!t]
  \begin{minipage}{.49\linewidth}
    \begin{algorithm}[H]
      \small
      \algrenewcommand\algorithmicrequire{\textbf{Input: }}
      \algrenewcommand\algorithmicensure{\textbf{Output: }}
      \caption{SSM (S4)}
      \label{alg:s4}
      \begin{algorithmic}[1]
        \Require $x : \mathtt{(B, L, D)}$
        \Ensure $y : \mathtt{(B, L, D)}$
        \State $\A : \mathtt{(D, N)} \gets \mathsf{Parameter}$

        \Comment{Represents structured $N \times N$ matrix}
        \State $\B : \mathtt{(D, N)} \gets \mathsf{Parameter}$
        \State $\C : \mathtt{(D, N)} \gets \mathsf{Parameter}$
        \State $\dt : \mathtt{(D)} \gets \tau_\dt(\mathsf{Parameter})$
        \State $\dA, \dB : \mathtt{(D, N)} \gets \mathsf{discretize}(\dt, \A, \B)$
        \State $y \gets \mathsf{SSM}(\dA, \dB, \C)(x)$

        \Comment{Time-invariant: recurrence or convolution}
        \State \textbf{return} $y$
      \end{algorithmic}
    \end{algorithm}
  \end{minipage}
  \begin{minipage}{.49\linewidth}
    \begin{algorithm}[H]
      \small
      \algrenewcommand\algorithmicrequire{\textbf{Input: }}
      \algrenewcommand\algorithmicensure{\textbf{Output: }}
      \caption{SSM + Selection (S6)}
      \label{alg:s6}
      \begin{algorithmic}[1]
        \Require $x : \mathtt{(B, L, D)}$
        \Ensure $y : \mathtt{(B, L, D)}$
        \State $\A : \mathtt{(D, N)} \gets \mathsf{Parameter}$

        \Comment{Represents structured $N \times N$ matrix}
        \State $\B : \textcolor{BrickRed}{\mathtt{(B, L, N)}} \gets \textcolor{BrickRed}{s_B(x)}$
        \State $\C : \textcolor{BrickRed}{\mathtt{(B, L, N)}} \gets \textcolor{BrickRed}{s_C(x)}$
        \State $\dt : \textcolor{BrickRed}{\mathtt{(B, L, D)}} \gets \tau_\dt(\mathsf{Parameter} \textcolor{BrickRed}{+ s_\dt(x)})$
        \State $\dA, \dB : \textcolor{BrickRed}{\mathtt{(B, L, D, N)}} \gets \mathsf{discretize}(\dt, \A, \B)$
        \State $y \gets \mathsf{SSM}(\dA, \dB, \C)(x)$

        \Comment{\textcolor{BrickRed}{Time-varying}: recurrence (\textcolor{BrickRed}{\emph{scan}}) only}
        \State \textbf{return} $y$
      \end{algorithmic}
    \end{algorithm}
  \end{minipage}
  \iftoggle{arxiv}{}{\vspace{-1em}}
\end{figure*}


\subsection{Efficient Implementation of Selective SSMs}
\label{sec:method:scan}

%

Hardware-friendly primitives such as convolutions~\citep{krizhevsky2012imagenet} and attention~\citep{bahdanau2015neural,vaswani2017attention} enjoy widespread application.
Here we aim to make selective SSMs efficient on modern hardware (GPUs) as well.
The selection mechanism is quite natural, and earlier works attempted to incorporate special cases of selection, such as letting $\dt$ vary over time in recurrent SSMs~\citep{gu2020hippo}.
However,
\iftoggle{arxiv}{
as previously mentioned a core limitation in the usage of SSMs is their computational efficiency,
}{
this was computationally difficult,
}
which was why S4 and all derivatives used LTI (non-selective) models, most commonly in the form of global convolutions.

\iftoggle{arxiv}{
\subsubsection{Motivation of Prior Models}

We first revisit this motivation and overview our approach to overcome limitations of prior methods.


\begin{itemize}[leftmargin=*,itemsep=0pt]
  \item At a high level, recurrent models such as SSMs always balance a tradeoff between expressivity and speed: as discussed in \cref{sec:method:motivation}, models with larger hidden state dimension should be more effective but slower. Thus we want to \emph{maximize hidden state dimension without paying speed and memory costs}.

  \item Note that the recurrent mode is more flexible than the convolution mode, since the latter \eqref{eq:ssm:convolution} is derived from expanding the former \eqref{eq:ssm:recurrence} \citep{gu2021combining,gu2022efficiently}.
  However, this would require computing and materializing the latent state $h$ with shape $\mathtt{(B,L,D,N)}$, which is much larger (by a factor of $N$, the SSM state dimension) than the input $x$ and output $y$ of shape $\mathtt{(B,L,D)}$.
  Thus the more efficient convolution mode was introduced which could bypass the state computation and materializes a convolution kernel \eqref{eq:ssm:convolution:1} of size only $\mathtt{(B,L,D)}$.

\item Prior LTI state space models leverage the dual recurrent-convolutional forms to increase the effective state dimension by a factor of $N$ ($\approx 10-100$), much larger than traditional RNNs, without efficiency penalties.
\end{itemize}



\subsubsection{Overview of Selective Scan: Hardware-Aware State Expansion}
}{}

The selection mechanism is designed to overcome the limitations of LTI models;
at the same time, we therefore need to revisit the computation problem of SSMs.
We address this with three classical techniques: kernel fusion, parallel scan, and recomputation.
We make two main observations:
\begin{itemize}[leftmargin=*,itemsep=0pt,topsep=0pt]
\item The naive recurrent computation uses $O(BLDN)$ FLOPs while the convolutional computation uses $O(BLD\log(L))$ FLOPs, and the former has a lower constant factor.
Thus for long sequences and not-too-large state dimension $N$, the recurrent mode can actually use fewer FLOPs.
\item The two challenges are the sequential nature of recurrence, and the large memory usage.
To address the latter, just like the convolutional mode, we can attempt to not actually materialize the full state $h$.
\end{itemize}

The main idea is to leverage properties of modern accelerators (GPUs) to materialize the state $h$ only in more efficient levels of the memory hierarchy.
In particular, most operations (except matrix multiplication)
are bounded by memory bandwidth~\citep{williams2009roofline,ivanov2021data,dao2022flashattention}.
This includes our scan operation,
and we use
kernel fusion to reduce the amount of memory IOs, leading to a significant speedup
compared to a standard implementation.

Concretely, instead of preparing the scan input
$\dAB$ of size $\mathtt{(B,L,D,N)}$ in GPU HBM
(high-bandwidth memory),
we load the SSM parameters $(\dt, \A, \B, \C)$ directly from slow HBM to fast SRAM,
perform the discretization and recurrence in SRAM,
and then write the final outputs of size $(\mathtt{B,L,D})$ back to HBM.

To avoid the sequential recurrence, we observe that
despite not being linear it can still be parallelized with a
work-efficient parallel scan algorithm~\citep{blelloch1990prefix,martin2018parallelizing,smith2023s5}.

\iftoggle{arxiv}{
Finally, we must also avoid saving the intermediate states, which are necessary for backpropagation.
We carefully apply the classic technique of recomputation to reduce the memory requirements: the intermediate states are not stored but recomputed in the backward pass when the inputs are loaded from HBM to SRAM.
As a result, the fused selective scan layer has the same memory requirements as an optimized
transformer implementation with FlashAttention.

}{}
Details of the fused kernel and recomputation are in~\cref{sec:hardware_aware_algo}.
\iftoggle{arxiv}{
  The full Selective SSM layer and algorithm is illustrated in \cref{fig:selection}.
}{}

\iftoggle{arxiv}{
%
}{}




\subsection{A Simplified SSM Architecture}
\label{sec:method:architecture}


As with structured SSMs, selective SSMs are standalone sequence transformations that can be flexibly incorporated into neural networks.
The H3 architecture is the basis for the most well-known SSM architectures (\cref{sec:background}), %
which are generally comprised of a block inspired by linear attention interleaved with an MLP (multi-layer perceptron) block.
We simplify this architecture by combining these two components into one, which is stacked homogenously (\cref{fig:architecture}).
\iftoggle{arxiv}{This is inspired by the gated attention unit (GAU)~\citep{hua2022transformer}, which did something similar for attention.}{}

This architecture involves expanding the model dimension $D$ by a controllable expansion factor $E$.
For each block, most of the parameters ($3ED^2$) are in the linear projections
\iftoggle{arxiv}{($2ED^2$ for input projections, $ED^2$ for output projection)}{}
while the inner SSM contributes less.
\iftoggle{arxiv}{
  The number of SSM parameters (projections for $\Delta, \B, \C$, and the matrix $\A$) are much smaller in comparison.
}{}%
\iftoggle{arxiv}{
  We repeat this block, interleaved with standard normalization and residual connections, to form the Mamba architecture.
}{}%
We always fix to $E=2$ in our experiments and use two stacks of the block to match the $12D^2$ parameters of a Transformer's interleaved MHA (multi-head attention) and MLP blocks.
\iftoggle{arxiv}{
We use the SiLU / Swish activation function~\citep{hendrycks2016gaussian,ramachandran2017swish},
motivated so that the Gated MLP becomes the popular ``SwiGLU'' variant~\citep{dauphin2017language,shazeer2020glu,chowdhery2022palm,touvron2023llama}.
}{}
\iftoggle{arxiv}{
Finally, we additionally use an optional normalization layer (we choose LayerNorm~\citep{ba2016layer}),
motivated by RetNet's usage of a normalization layer in a similar location~\citep{sun2023retentive}.
}{}

%

\begin{figure*}[!t]
  \centering
  \includegraphics[width=\iftoggle{arxiv}{0.9\linewidth}{0.75\linewidth}]{fig/architecture.pdf}
  \caption{
    (\textbf{Architecture}.) Our simplified block design combines the H3 block, which is the basis of most SSM architectures, with the ubiquitous MLP block of modern neural networks. Instead of interleaving these two blocks, we simply repeat the Mamba block homogenously.
    Compared to the H3 block, Mamba replaces the first multiplicative gate with an activation function.
    Compared to the MLP block, Mamba adds an SSM to the main branch.
    For $\sigma$ we use the SiLU / Swish activation~\citep{hendrycks2016gaussian,ramachandran2017swish}.
  }
  \label{fig:architecture}
  \iftoggle{arxiv}{}{\vspace{-1.25em}}
\end{figure*}

\subsection{Properties of Selection Mechanisms}
\label{sec:method:properties}

The selection mechanism is a broader concept that can be applied in different ways,
such as to more traditional RNNs or CNNs, to different parameters (e.g. $\A$ in \cref{alg:s6}), or using different transformations $s(x)$.

\iftoggle{arxiv}{
  \subsubsection{Connection to Gating Mechanisms}
}{}
We highlight the most important connection: the classical gating mechanism of RNNs is an instance of our selection mechanism for SSMs.
We note that the connection between RNN gating and the discretization of continuous-time systems is well established~\citep{funahashi1993approximation,tallec2018can}.
In fact, \cref{thm:gating} is an improvement of \citet[Lemma 3.1]{gu2021combining} generalizing to the ZOH discretization and input-dependent gates (proof in \cref{sec:mechanics}).
More broadly, $\dt$ in SSMs can be seen to play a generalized role of the RNN gating mechanism.
In line with prior work, we adopt the view that \emph{discretization of SSMs is the principled foundation of heuristic gating mechanisms}.
\begin{theorem}
  \label{thm:gating}
  When $N=1, \A=-1, \B=1, s_\dt=\mathsf{Linear}(x)$, and $\tau_\dt=\mathsf{softplus}$,
  then the selective SSM recurrence (\cref{alg:s6}) takes the form
  \iftoggle{arxiv}{
    \begin{equation}%
      \label{eq:gates}
      \begin{aligned}
        g_t &= \sigma(\mathsf{Linear}(x_t)) \\
        h_{t} &= (1-g_t) h_{t-1} + g_t x_t
        .
      \end{aligned}
    \end{equation}
  }{
    $g_t = \sigma(\mathsf{Linear}(x_t))$ (the \emph{gate}) and $h_{t} = (1-g_t) h_{t-1} + g_t x_t$.
  }
\end{theorem}

As mentioned in \cref{sec:method:selective}, our specific choices of $s_\dt, \tau_\dt$ is from this connection.
In particular, note that if a given input $x_t$ should be completely ignored (as necessary in the synthetic tasks),
all $D$ channels should ignore it, and so we project the input down to $1$ dimension before repeating/broadcasting with $\dt$.


\iftoggle{arxiv}{
\subsubsection{Interpretation of Selection Mechanisms}
}{}

We elaborate on \iftoggle{arxiv}{three}{two} particular mechanistic effects of selection.

\para{Variable Spacing.}
Selectivity allows filtering out irrelevant noise tokens that may occur between inputs of interest.
This is exemplified by the Selective Copying task, but occurs ubiquitously in common data modalities, particularly for discrete data -- for example the presence of language fillers such as ``um''.
This property arises because the model can mechanistically filter out any particular input $x_t$, for example in the gated RNN case (\cref{thm:gating}) when $g_t \to 0$.

\para{Filtering Context.}
It has been empirically observed that many sequence models do not improve with longer context~\citep{shi2023large}, despite the principle that more context should lead to strictly better performance. %
An explanation is that many sequence models cannot effectively ignore irrelevant context when necessary; an intuitive example are global convolutions (and general LTI models).
On the other hand, selective models can simply reset their state at any time to remove extraneous history,
and thus their performance in principle improves monotonicly with context length (e.g.\ \cref{sec:exp:dna:length}).

\iftoggle{arxiv}{
  \para{Boundary Resetting.}
  In settings where multiple independent sequences are stitched together, Transformers can keep them separate by instantiating a particular attention mask,
  while LTI models will bleed information between the sequences.
  Selective SSMs can also reset their state at boundaries (e.g.\ $\Delta_t \to \infty$, or \cref{thm:gating} when $g_t \to 1$).
  These settings may occur artificially (e.g. packing documents together to improve hardware utilization)
  or naturally (e.g.\ episode boundaries in reinforcement learning~\citep{lu2023structured}).
}{}

%

\iftoggle{arxiv}{
Additionally, we elaborate on effects of each selective parameter.

\paragraph{Interpretation of $\dt$.}
In general, $\dt$ controls the balance between how much to focus or ignore the current input $x_t$.
It generalizes RNN gates (e.g.\ $g_t$ in \cref{thm:gating}):
mechanically, a large $\dt$ resets the state $h$ and focuses on the current input $x$,
while a small $\dt$ persists the state and ignores the current input.
SSMs \eqref{eq:ssm}-\eqref{eq:ssm:recurrence} can be interpreted as a continuous system discretized by a timestep $\dt$,
and in this context the intuition is that large $\dt \to \infty$ represents the system focusing on the current input for longer (thus ``selecting'' it and forgetting its current state)
while a small $\dt \to 0$ represents a transient input that is ignored.

\paragraph{Interpretation of $\A$.}
}

We remark that while the $\A$ parameter could also be selective, it ultimately affects the model only through its interaction with $\dt$ via $\dA = \exp(\dt \A)$ (the discretization\iftoggle{arxiv}{~\eqref{eq:zoh})}{}.
Thus selectivity in $\dt$ is enough to ensure selectivity in $\dAB$, and is the main source of improvement.
We hypothesize that making $\A$ selective in addition to (or instead of) $\dt$ would have similar performance,
and leave it out for simplicity.

\iftoggle{arxiv}{
\paragraph{Interpretation of $\B$ and $\C$.}
As discussed in \cref{sec:method:motivation}, the most important property of selectivity is filtering out irrelevant information
so that a sequence model's context can be compressed into an efficient state.
In an SSM, modifying $\B$ and $\C$ to be selective allows finer-grained control over whether to let an input $x_t$ into the state $h_t$, or the state into the output $y_t$.
These can be interpreted as allowing the model to modulate the recurrent dynamics based on content (input) and context (hidden states) respectively.

}

\iftoggle{arxiv}{
\subsection{Additional Model Details}
\label{sec:method:details}

%

\paragraph{Real vs.\ Complex.}
Most prior SSMs use complex numbers in their state $h$, which is necessary for strong performance on many tasks in perceptual modalities~\citep{gu2022efficiently}.
However, it has been empirically observed that completely real-valued SSMs seem to work fine, and possibly even better, in some settings~\citep{ma2023mega}.
We use real values as the default, which work well for all but one of our tasks;
we hypothesize that the complex-real tradeoff is related to the continuous-discrete spectrum in data modalities, where complex numbers are helpful for continuous modalities (e.g.\ audio, video) but not discrete (e.g.\ text, DNA).

\paragraph{Initialization.}
Most prior SSMs also suggest special initializations, particularly in the complex-valued case, which can help in several settings such as low-data regimes.
Our default initialization for the complex case is S4D-Lin
and for the real case is S4D-Real~\citep{gu2022parameterization},
which is based on the HIPPO theory~\citep{gu2020hippo}.
These define the $n$-th element of $\A$ as $-1/2 + n i$
and $-(n+1)$ respectively.
However, we expect many initializations to work fine, particularly in the large-data and real-valued SSM regimes;
some ablations are considered in \cref{sec:exp:ablations}.

\paragraph{Parameterization of $\dt$.}
We defined the selective adjustment to $\dt$ as $s_\dt(x) = \mathsf{Broadcast}_D(\mathsf{Linear}_1(x))$,
which was motivated by the mechanics of $\dt$ (\cref{sec:method:properties}).
We observe that it can be generalized
from dimension $1$ to a larger dimension $\mathtt{R}$.
We set this to be a small fraction of $\mathtt{D}$,
which uses a negligible number of parameters compared to the main Linear projections in the block.
We additionally note that the broadcasting operation can instead
be viewed as another Linear projection, initialized to a specific pattern of $1$'s and $0$'s;
if this projection is trainable, this leads to the alternative $s_\dt(x) = \mathsf{Linear}_D(\mathsf{Linear}_R(x))$, which can be viewed as a low-rank projection.

In our experiments, the $\dt$ parameter (which can be viewed as a bias term) is initialized to $\tau_\dt^{-1}(\mathsf{Uniform}([0.001, 0.1]))$,
following prior work on SSMs~\citep{gu2023train}.

%
}


\begin{remark}
  For brevity in our experimental results, we sometimes abbreviate selective SSMs as \emph{S6 models}, because they are S4 models with a \emph{selection} mechanism and computed with a \emph{scan}.
\end{remark}



% ========== END CONTENT FROM src/method.tex ==========



% ========== BEGIN CONTENT FROM src/experiments.tex ==========
\section{Empirical Evaluation}
\label{sec:exps}

\iftoggle{arxiv}{
In \cref{sec:exp:synthetic} we test Mamba's ability to solve the two synthetic tasks motivated in \cref{sec:method:motivation}.
We then evaluate on three domains, each evaluated on autoregressive pretraining as well as downstream tasks.
\begin{itemize}[leftmargin=*,itemsep=0pt,topsep=0pt]
  \item \cref{sec:exp:language}: language model pretraining (scaling laws), and zero-shot downstream evaluation.
  \item \cref{sec:exp:genomics}: DNA sequence pretraining, and fine-tuning on a long-sequence classification task.
  \item \cref{sec:exp:audio}: audio waveform pretraining, and the quality of autoregressively generated speech clips.
\end{itemize}
Finally, \cref{sec:exp:benchmark} shows Mamba's computational efficiency at both training and inference time,
and \cref{sec:exp:ablations} ablates various components of the architecture and selective SSMs.
}{
  Mamba achieves state-of-the-art results on the synthetic tasks (\cref{sec:exp:synthetic}) and three different domains (language, DNA, audio) (\cref{sec:exp:language,sec:exp:genomics,sec:exp:audio}) on both pretraining and downstream tasks,
  while being very computationally efficient (\cref{sec:exp:benchmark}).
}

\subsection{Synthetic Tasks}
\label{sec:exp:synthetic}

\iftoggle{arxiv}{
  \input{src/synthetic.tex}
}{
\cref{tab:copying} and \cref{fig:induction} show results for the synthetic tasks.
On Selective Copying, the selective SSM layer is enough to solve the task independently of the architecture used,
while previous LTI SSMs cannot even when combined with more powerful architectures.
On Induction Heads, Mamba learns the task perfectly and can even extrapolate to
million-length sequences, or $4000\times$ longer than it saw during training,
while no other method goes beyond $2\times$.
Full discussion for synthetic tasks are in \cref{sec:exp-full:synthetic}.
}


\begin{figure*}
  \begin{minipage}{0.33\linewidth}
    \iftoggle{arxiv}{\small}{\footnotesize}
    \centering
    \begin{tabular}{@{}llll@{}}
      \toprule
      \textsc{Model}          & \textsc{Arch.}        & \textsc{Layer}      & \textsc{Acc.} \\
      \midrule
      S4                       & No gate               & S4                  & 18.3 \\
      -                       & No gate               & S6                  & \textbf{97.0} \\
      \midrule
      H3                      & H3                    & S4                  & 57.0 \\
      Hyena                   & H3                    & Hyena               & 30.1 \\
      -                       & H3                    & S6                  & \textbf{99.7} \\
      \midrule
      -                       & Mamba                 & S4                  & 56.4 \\
      -                       & Mamba                 & Hyena               & 28.4 \\
      Mamba                   & Mamba                 & S6                  & \textbf{99.8} \\
      \bottomrule
    \end{tabular}
    \iftoggle{arxiv}{
      \captionsetup{type=table,skip=12pt}
    }{
      \captionsetup{type=table,skip=12pt}
    }
    \caption{
      (\textbf{Selective Copying}.) \\
      Accuracy for combinations of architectures and inner sequence layers.
    }
    \label{tab:copying}
  \end{minipage}
  \hfill
  \begin{minipage}{\iftoggle{arxiv}{0.55\linewidth}{0.63\linewidth}}
    \centering
    \includegraphics[width=\linewidth]{fig/induction.pdf}
    \iftoggle{arxiv}{
      \captionsetup{type=table,skip=-6pt}
    }{
      \captionsetup{type=figure,skip=-12pt}
    }
    \caption{
      (\textbf{Induction Heads}.)
      Models are trained on sequence length $2^8=256$, and tested on increasing sequence lengths of $2^6=64$ up to $2^{20}=1048576$.
      Full numbers in \cref{tab:induction}.
    }
    \label{fig:induction}
  \end{minipage}
\end{figure*}


\subsection{Language Modeling}
\label{sec:exp:language}

We evaluate the Mamba architecture on standard autoregressive language modeling against other architectures, on both pretraining metrics (perplexity) and zero-shot evaluations.
We set the model sizes (depth and width) to mirror GPT3 specifications. %
We use the Pile dataset~\citep{pile}, and follow the training recipe described in~\citet{brown2020language}. 
All training details are in~\cref{sec:exp-details:lm}.


\iftoggle{arxiv}{
  \subsubsection{Scaling Laws}
}{
  \para{Scaling Laws.}
}
For baselines, we compare against the standard Transformer architecture (GPT3 architecture), as well as the strongest Transformer recipe we know of (here referred to as Transformer++), based on the PaLM and LLaMa architectures (e.g.\ rotary embedding, SwiGLU MLP, \iftoggle{arxiv}{RMSNorm instead of LayerNorm, no linear bias, and higher learning rates}{etc.}).
We also compare against other recent subquadratic architectures (\cref{fig:lm-scaling}).
All model details are in \cref{sec:exp-details:lm}.

\iftoggle{arxiv}{
\cref{fig:lm-scaling} shows scaling laws under the standard Chinchilla~\citep{hoffmann2022empirical} protocol,
on models from $\approx 125M$ to $\approx 1.3B$ parameters.
\textbf{Mamba is the first attention-free model to match the performance of a very strong Transformer recipe (Transformer++) that has now become standard,
particularly as the sequence length grows.}
(We note that full results on context length 8k are missing for the RWKV and RetNet baselines,
prior strong recurrent models that can also be interpreted as SSMs, because of a lack of efficient implementations leading to out-of-memory or unrealistic computation requirements.)
}{}

\begin{figure*}[!t]
  \centering
  \begin{subfigure}[t]{0.49\linewidth}
    \centering
    \includegraphics[width=\textwidth]{fig/pile_2k.pdf}
  \end{subfigure}
  \begin{subfigure}[t]{0.49\linewidth}
    \centering
    \includegraphics[width=\textwidth]{fig/pile_8k.pdf}
  \end{subfigure}
  \caption{
    (\textbf{Scaling Laws}.) %
    Models of size $\approx 125M$ to $\approx 1.3B$ parameters, trained on the Pile.
    Mamba scales better than all other attention-free models and is the first to match the performance of a very strong ``Transformer++'' recipe that has now become standard,
    particularly as the sequence length grows.
  }
  \label{fig:lm-scaling}
  \iftoggle{arxiv}{}{\vspace{-1em}}
\end{figure*}


\iftoggle{arxiv}{
  \subsubsection{Downstream Evaluations}
}{
  \para{Downstream Evaluations.}
}
\cref{table:downstream_zeroshot} shows the performance of Mamba on a range of popular downstream zero-shot evaluation tasks.
We compare against the most well-known open source models at these sizes,
most importantly Pythia~\citep{biderman2023pythia} and RWKV~\citep{peng2023rwkv} which were trained with the same tokenizer, dataset, and training length (300B tokens) as our models.
\iftoggle{arxiv}{(Note that Mamba and Pythia are trained with context length 2048, while RWKV was trained with context length 1024.)}{}




\begin{table*}[!th]
  \small
  \centering
  \captionsetup{font=small}
  \caption{
    (\textbf{Zero-shot Evaluations}.) Best results for each size in bold.
    We compare against open source LMs with various tokenizers, trained for up to 300B tokens.
    Pile refers to the validation split, comparing only against models trained on the same dataset and tokenizer (GPT-NeoX-20B).
    For each model size, Mamba is best-in-class on every single evaluation result,
    and generally matches baselines at twice the model size.
    %
  }
  \resizebox{0.99\linewidth}{!}
  {
    \begin{tabular}{@{}lllllllllll@{}}
      \toprule
      \sc{Model}                                        & \sc{Token.} & \sc{Pile}             & \sc{LAMBADA}          & \sc{LAMBADA}         & \sc{HellaSwag}       & \sc{PIQA}            & \sc{Arc-E}           & \sc{Arc-C}           & \sc{WinoGrande}      & \sc{Average} \\
                                                        &             & \sc{ppl $\downarrow$} & \sc{ppl $\downarrow$} & \sc{acc $\uparrow$}  & \sc{acc $\uparrow$}  & \sc{acc $\uparrow$}  & \sc{acc $\uparrow$}  & \sc{acc $\uparrow$}  & \sc{acc $\uparrow$}  & \sc{acc $\uparrow$} \\
                                        \midrule
      \iftoggle{arxiv}{
      Hybrid H3-130M                                           & GPT2        & ---                   & 89.48                 & 25.77                & 31.7                 & 64.2                 & 44.4                 & 24.2                 & 50.6                 & 40.1 \\
      Pythia-160M                                       & NeoX        & 29.64                 & 38.10                 & 33.0                 & 30.2                 & 61.4                 & 43.2                 & 24.1                 & \textbf{51.9}        & 40.6 \\
      \textbf{Mamba-130M}                               & NeoX        & \textbf{10.56}        & \textbf{16.07}        & \textbf{44.3}        & \textbf{35.3}        & \textbf{64.5}        & \textbf{48.0}        & \textbf{24.3}        & \textbf{51.9}        & \textbf{44.7} \\
      \midrule
      }{}
      Hybrid H3-360M                                           & GPT2        & ---                   & 12.58                 & 48.0                 & 41.5                 & 68.1                 & 51.4                 & 24.7                 & 54.1                 & 48.0 \\
      Pythia-410M                                       & NeoX        & 9.95                  & 10.84                 & 51.4                 & 40.6                 & 66.9                 & 52.1                 & 24.6                 & 53.8                 & 48.2 \\
      \textbf{Mamba-370M}                               & NeoX        & \textbf{8.28}         & \textbf{8.14}         & \textbf{55.6}        & \textbf{46.5}        & \textbf{69.5}        & \textbf{55.1}        & \textbf{28.0}        & \textbf{55.3}        & \textbf{50.0} \\
      \midrule
      Pythia-1B                                         & NeoX        & 7.82                  & 7.92                  & 56.1                 & 47.2                 & 70.7                 & 57.0                 & 27.1                 & 53.5                 & 51.9 \\
      \textbf{Mamba-790M}                               & NeoX        & \textbf{7.33}         & \textbf{6.02}         & \textbf{62.7}        & \textbf{55.1}        & \textbf{72.1}        & \textbf{61.2}        & \textbf{29.5}        & \textbf{56.1}        & \textbf{57.1} \\
      \midrule
      GPT-Neo 1.3B                                      & GPT2        & ---                   & 7.50                  & 57.2                 & 48.9                 & 71.1                 & 56.2                 & 25.9                 & 54.9                 & 52.4 \\
      Hybrid H3-1.3B                                           & GPT2        & ---                   & 11.25                 & 49.6                 & 52.6                 & 71.3                 & 59.2                 & 28.1                 & 56.9                 & 53.0 \\
      OPT-1.3B                                          & OPT         & ---                   & 6.64                  & 58.0                 & 53.7                 & 72.4                 & 56.7                 & 29.6                 & 59.5                 & 55.0 \\
      Pythia-1.4B                                       & NeoX        & 7.51                  & 6.08                  & 61.7                 & 52.1                 & 71.0                 & 60.5                 & 28.5                 & 57.2                 & 55.2 \\
      RWKV-1.5B                                         & NeoX        & 7.70                  & 7.04                  & 56.4                 & 52.5                 & 72.4                 & 60.5                 & 29.4                 & 54.6                 & 54.3 \\
      \textbf{Mamba-1.4B}                               & NeoX        & \textbf{6.80}         & \textbf{5.04}         & \textbf{64.9}        & \textbf{59.1}        & \textbf{74.2}        & \textbf{65.5}        & \textbf{32.8}        & \textbf{61.5}        & \textbf{59.7} \\
      \midrule
      GPT-Neo 2.7B                                      & GPT2        & ---                   & 5.63                  & 62.2                 & 55.8                 & 72.1                 & 61.1                 & 30.2                 & 57.6                 & 56.5 \\
      Hybrid H3-2.7B                                           & GPT2        & ---                   & 7.92                  & 55.7                 & 59.7                 & 73.3                 & 65.6                 & 32.3                 & 61.4                 & 58.0 \\
      OPT-2.7B                                          & OPT         & ---                   & 5.12                  & 63.6                 & 60.6                 & 74.8                 & 60.8                 & 31.3                 & 61.0                 & 58.7 \\
      Pythia-2.8B                                       & NeoX        & 6.73                  & 5.04                  & 64.7                 & 59.3                 & 74.0                 & 64.1                 & 32.9                 & 59.7                 & 59.1 \\
      RWKV-3B                                           & NeoX        & 7.00                  & 5.24                  & 63.9                 & 59.6                 & 73.7                 & 67.8                 & 33.1                 & 59.6                 & 59.6 \\
      \textbf{Mamba-2.8B}                               & NeoX        & \textbf{6.22}         & \textbf{4.23}         & \textbf{69.2}        & \textbf{66.1}        & \textbf{75.2}        & \textbf{69.7}        & \textbf{36.3}        & \textbf{63.5}        & \textbf{63.3} \\
      \midrule
      GPT-J-6B                                          & GPT2        & --                    & 4.10                  & 68.3                 & 66.3                 & 75.4                 & 67.0                 & 36.6                 & 64.1                 & 63.0 \\
      OPT-6.7B                                          & OPT         & --                    & 4.25                  & 67.7                 & 67.2                 & 76.3                 & 65.6                 & 34.9                 & 65.5                 & 62.9 \\
      Pythia-6.9B                                       & NeoX        & 6.51                  & 4.45                  & 67.1                 & 64.0                 & 75.2                 & 67.3                 & 35.5                 & 61.3                 & 61.7 \\
      RWKV-7.4B                                         & NeoX        & 6.31                  & 4.38                  & 67.2                 & 65.5                 & 76.1                 & 67.8                 & 37.5                 & 61.0                 & 62.5 \\
      \bottomrule
    \end{tabular}
  }
  \label{table:downstream_zeroshot}
\end{table*}

\subsection{DNA Modeling}
\label{sec:exp:genomics}

Motivated by the success of large language models, there
has been recent exploration into using the foundation model paradigm for genomics.
DNA has been likened to language in that it consists of sequences of discrete tokens with a finite vocabulary.
It is also known for requiring long-range dependencies to model \citep{avsec2021effective}.
We investigate Mamba as a FM backbone for pretraining and fine-tuning in the same setting as recent works on long-sequence models for DNA \citep{nguyen2023hyenadna}.
In particular, we focus on two explorations of scaling laws across model size and sequence length (\cref{fig:dna}), and a difficult downstream synthetic classification task requiring long context (\cref{fig:species}).
\iftoggle{arxiv}{

  \input{src/dna}
}{
  Full discussion for these tasks is in \cref{sec:exp-full:genomics}.
}


\begin{figure*}[!t]
  \centering
\begin{subfigure}{.49\linewidth}%
  \centering
  \includegraphics[width=\linewidth]{fig/dna_scaling.pdf}
\end{subfigure}
\begin{subfigure}{.49\linewidth}%
  \centering
  \includegraphics[width=\linewidth]{fig/dna_length.pdf}
\end{subfigure}
\caption{
  (\textbf{DNA Scaling Laws}.) Pretraining on the HG38 (human genome) dataset.
  (\textit{Left}) Fixing short context length $2^{10}=1024$ and increasing size from $\approx200K$ to $\approx 40M$ parameters, Mamba scales better than baselines.
  (\textit{Right}) Fixing model size and increasing sequence lengths while \iftoggle{arxiv}{keeping tokens/batch and total training tokens fixed}{controlling for computation}.
  Unlike baselines, the selection mechanism of Mamba facilitates better performance with increasing context length.
}
\label{fig:dna}
\end{figure*}


\begin{figure*}[!ht]
  \begin{minipage}[t]{.49\linewidth}
    \centering
    \includegraphics[width=\linewidth]{fig/species.pdf}
    \captionsetup{type=figure}
    \caption{
      (\textbf{Great Apes DNA Classification}.)
      Accuracy after fine-tuning on sequences of length $2^{10}=1024$ up to $2^{20}=1048576$ using pretrained models of the same context length.
      Numerical results in \cref{tab:species}.
    }
    \label{fig:species}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{.49\linewidth}
    \centering
    \includegraphics[width=\linewidth]{fig/youtubemix.pdf}
    \captionsetup{type=figure}
    \caption{
      (\textbf{Audio Pretraining}.) Mamba improves performance over prior state-of-the-art (Sashimi) in autoregressive audio modeling, while improving up to minute-long context or million-length sequences\iftoggle{arxiv}{ (controlling for computation)}{}.
    }
    \label{fig:youtubemix}
  \end{minipage}
\end{figure*}


\subsection{Audio Modeling and Generation}
\label{sec:exp:audio}

For the audio waveform modality, we compare primarily to the SaShiMi architecture and training protocols~\citep{goel2022raw}.
\iftoggle{arxiv}{
  This model comprises:
\begin{enumerate}
  \item a U-Net backbone with two stages of pooling by a factor $p$ that doubles the model dimension $D$ per stage,
  \item alternating S4 and MLP blocks in each stage.
\end{enumerate}
We consider replacing the S4+MLP blocks with Mamba blocks.
}{
  The architecture is a U-Net with alternating S4 and MLP blocks, which we consider replacing with Mamba.
}
  Experiment details are in \cref{sec:exp-details:audio}.

\iftoggle{arxiv}{
\subsubsection{Long-Context Autoregressive Pretraining}
}{
\para{Long-Context Autoregressive Pretraining.}%
}
We evaluate pretraining quality \iftoggle{arxiv}{(autoregressive next-sample prediction)}{} on YouTubeMix~\citep{deepsound},
a standard piano music dataset\iftoggle{arxiv}{ used by prior work consisting of $4$ hours of solo piano music, sampled at a rate of 16000 Hz}{}.
\iftoggle{arxiv}{Pretraining details largely follow the standard language modeling setup (\cref{sec:exp:language}).}{}
\cref{fig:youtubemix} evaluates the effect of increasing training sequence lengths from $2^{13}=8192$ to $2^{20}\approx 10^6$, while keeping computation fixed.
\iftoggle{arxiv}{
(There are some slight edge cases to the way the data is curated, which may lead to kinks in the scaling curves. For example, only minute-long clips were available so the maximum sequence length is actually bounded by $60s \cdot 16000Hz = 960000$.)

\textbf{Both Mamba and the SaShiMi (S4+MLP) baseline improve consistently with longer context lengths; Mamba is better throughout, and the gap widens at longer lengths.}
The main metric is bits per byte (BPB), which is a constant factor $\log(2)$ of the standard negative log-likelihood (NLL) loss for pretraining other modalities.

We note one important detail: this is the only experiment in this paper in which we switched from the real parameterization to complex (\cref{sec:method:details}).
We show additional ablations in \cref{sec:exp-details:audio}.
%
}{}


\iftoggle{arxiv}{
\subsubsection{Autoregressive Speech Generation}
}{
\para{Autoregressive Speech Generation.}
}
\iftoggle{arxiv}{
SC09 is a benchmark speech generation dataset~\citep{Warden2018SpeechCA,donahue2019adversarial}, consisting of $1$-second clips sampled at 16000 Hz of the digits ``zero'' through ``nine'' with highly variable characteristics. %
We largely follow the autoregressive training setup and generation protocol of \citet{goel2022raw}.

\cref{tab:sc09} shows automated metrics of the Mamba-UNet model compared to a variety of baselines from \citet{goel2022raw}:
WaveNet~\citep{oord2016wavenet}, SampleRNN~\citep{mehri2017samplernn}, WaveGAN~\citep{donahue2019adversarial}, DiffWave~\citep{kong2021diffwave}, and SaShiMi.
\textbf{A small Mamba model outperforms the state-of-the-art (and much larger) GAN- and diffusion- based models.}
A larger model parameter-matched to the baselines further improves on fidelity metrics dramatically.

\cref{tab:sc09-ablations} takes the small Mamba model and investigates combinations of different architectures for the outer stages and center stage.
It shows that Mamba is consistently better than S4+MLP in the outer blocks,
and Mamba $>$ S4+MLP $>$ MHA+MLP in the center blocks.
}{
  \cref{tab:sc09,tab:sc09-ablations} show results on the SC09 dataset for generating speech clips of the digits 0-9~\citep{Warden2018SpeechCA,donahue2019adversarial}.
  Mamba sets significant state-of-the-art results, and is consistently better than attention or S4 blocks in a parameter-controlled setting.
}

\begin{figure*}[!ht]
  \begin{minipage}[t]{.50\linewidth}
    \centering
    \captionsetup{type=table}
    \caption{
      (\textbf{SC09}) Automated metrics for unconditional generation on a challenging dataset of fixed-length speech clips.
      (\emph{Top to Bottom}) Autoregressive baselines, non-autoregressive baselines, Mamba, and dataset metrics.
    }
    \scriptsize
    \begin{tabular}{@{}lllllll@{}}
      \toprule
      \textsc{Model} & \textsc{Params} & \textsc{NLL $\downarrow$} & \textsc{FID $\downarrow$} & \textsc{IS $\uparrow$} & \textsc{mIS $\uparrow$} & \textsc{AM $\downarrow$}      \\
      \midrule
      SampleRNN      & 35.0M           & 2.042                     & 8.96                      & 1.71                   & 3.02                    & 1.76                                \\
      WaveNet        & 4.2M            & 1.925                     & 5.08                      & 2.27                   & 5.80                    & 1.47                                \\
      SaShiMi        & 5.8M            & 1.873                     & 1.99                      & 5.13                   & 42.57                   & 0.74                           \\
      \midrule
      WaveGAN        & 19.1M           & -                         & 2.03                      & 4.90                   & 36.10                   & 0.80                                \\
      DiffWave       & 24.1M           & -                         & 1.92                      & 5.26                   & 51.21                   & 0.68                                \\
      \;\; + SaShiMi & 23.0M           & -                         & 1.42                      & 5.94                   & 69.17                   & 0.59                           \\
      \midrule
      \textbf{Mamba} & 6.1M            & \textbf{1.852}            & \underline{0.94}          & \underline{6.26}       & \underline{88.54}       & \underline{0.52}                           \\
      \textbf{Mamba} & 24.3M           & \underline{1.860}         & \textbf{0.67}             & \textbf{7.33}          & \textbf{144.9}          & \textbf{0.36}                           \\
      \midrule
      Train          & -               & -                         & $0.00$                    & $8.56$                 & $292.5$                 & $0.16$                                \\
      Test           & -               & -                         & $0.02$                    & $8.33$                 & $257.6$                 & $0.19$                                \\
      \bottomrule
    \end{tabular}
    \label{tab:sc09}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{.49\linewidth}
    \centering
    \captionsetup{type=table}
    \caption{
      (\textbf{SC09 Model Ablations}) Models with 6M parameters. In SaShiMi's U-Net backbone, there are 8 center blocks operating on sequence length $1000$, sandwiched on each side by 8 outer blocks on sequence length $4000$, sandwiched by 8 outer blocks on sequence length $16000$ (40 blocks total). The architecture of the 8 center blocks are ablated independently of the rest. Note that Transformers (MHA+MLP) were not tested in the more important outer blocks because of efficiency constraints.
    }
    \scriptsize
    \begin{tabular}{@{}lllllll@{}}
      \toprule
      \textsc{Outer} & \textsc{Center} & \textsc{NLL $\downarrow$} & \textsc{FID $\downarrow$} & \textsc{IS $\uparrow$} & \textsc{mIS $\uparrow$} & \textsc{AM $\downarrow$}      \\
      \midrule
      S4+MLP         & MHA+MLP         & 1.859                     & 1.45                      & 5.06                   & 47.03                   & 0.70 \\
      S4+MLP         & S4+MLP          & 1.867                     & 1.43                      & 5.42                   & 53.54                   & 0.65 \\
      S4+MLP         & Mamba           & 1.859                     & 1.42                      & 5.71                   & 56.51                   & 0.64 \\
      Mamba          & MHA+MLP         & \textbf{1.850}            & 1.37                      & 5.63                   & 58.23                   & 0.62 \\
      Mamba          & S4+MLP          & 1.853                     & \underline{1.07}          & \underline{6.05}       & \underline{73.34}       & \underline{0.55} \\
      Mamba          & Mamba           & \underline{1.852}         & \textbf{0.94}             & \textbf{6.26}          & \textbf{88.54}          & \textbf{0.52} \\
      \bottomrule
    \end{tabular}
    \label{tab:sc09-ablations}
  \end{minipage}
\end{figure*}


\iftoggle{arxiv}{
  \input{src/benchmarks}

}{}
\begin{figure*}[!th]
  \centering
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=.95\linewidth]{fig/ssm_scan.pdf}
  \end{subfigure}%
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics[width=.95\linewidth]{fig/mamba_inference.pdf}
  \end{subfigure}
  \caption{
    (\textbf{Efficiency Benchmarks}.)
    (\emph{Left}) Training: our efficient scan is $40\times$ faster than a standard implementation.
    (\emph{Right}) Inference: as a recurrent model, Mamba can achieve $5\times$ higher throughput than Transformers.
  }
  \label{fig:scan_benchmark}
\end{figure*}


\iftoggle{arxiv}{

  \input{src/ablations}

}{
}



% ========== END CONTENT FROM src/experiments.tex ==========


\iftoggle{arxiv}{

% ========== BEGIN CONTENT FROM src/discussion.tex ==========
\section{Discussion}
\label{sec:discussion}

We discuss related work, limitations, and some future directions.

\paragraph{Related Work.}
\cref{sec:discussion:selection} discusses how the selection mechanism relates to similar concepts.
\cref{sec:related} has an extended related work of SSMs and other related models.

\paragraph{No Free Lunch: Continuous-Discrete Spectrum.}
Structured SSMs were originally defined as discretizations of continuous systems \eqref{eq:ssm},
and have had a strong inductive bias toward continuous-time data modalities such as perceptual signals (e.g.\ audio, video).
As discussed in \cref{sec:method:motivation,sec:method:properties}, the selection mechanism overcomes their weaknesses
on discrete modalities such as text and DNA;
but this conversely can impede their performance on data that LTI SSMs excel on.
Our ablations on audio waveforms examine this tradeoff in more detail.

\paragraph{Downstream Affordances.}
Transformer-based foundation models (particularly LLMs) have a rich ecosystem of properties and modes of interaction with pretrained models,
such as fine-tuning, adaptation, prompting, in-context learning, instruction tuning, RLHF, quantization, and so on.
We are particularly interested in whether Transformer alternatives such as SSMs have similar properties and affordances.

%

\paragraph{Scaling.}
Our empirical evaluation is limited to small model sizes,
below the threshold of most strong open source LLMs (e.g. Llama \citep{touvron2023llama})
as well as other recurrent models such as RWKV~\citep{peng2023rwkv} and RetNet~\citep{sun2023retentive},
which have been evaluated at the 7B parameter scale and beyond.
It remains to assess whether Mamba still compares favorably at these larger sizes.
We also note that scaling SSMs may involve further engineering challenges and adjustments to the model
that are not discussed in this paper.

%

% ========== END CONTENT FROM src/discussion.tex ==========

}{}


% ========== BEGIN CONTENT FROM src/conclusion.tex ==========
\section{Conclusion}
\label{sec:conclusion}

We introduce a selection mechanism to structured state space models, allowing them to perform context-dependent reasoning while scaling linearly in sequence length.
When incorporated into a simple attention-free architecture, Mamba achieves state-of-the-art results on a diverse set of domains,
where it matches or exceeds the performance of strong Transformer models.
We are excited about the broad applications of selective state space models to build foundation models for different domains, especially in emerging modalities requiring long context such as genomics, audio, and video.
Our results suggest that Mamba is a strong candidate to be a general sequence model backbone.

% ========== END CONTENT FROM src/conclusion.tex ==========


\iftoggle{arxiv}{
\subsubsection*{Acknowledgments}

We thank Karan Goel, Arjun Desai, and Kush Bhatia for helpful feedback on the draft.

}{

}


\iftoggle{arxiv}{
\printbibliography
}{
\bibliography{biblio}
}


\newpage

\appendix

\onecolumn


% ========== BEGIN CONTENT FROM src/related.tex ==========
\section{Discussion: Selection Mechanism}
\label{sec:discussion:selection}

Our selection mechanism is inspired by and related to concepts such as gating, hypernetworks, and data-dependence.
It can also be viewed as related to ``fast weights''~\citep{schmidhuber1992learning,ba2016using}, which connects classical RNNs with the mechanism of linear attention~\citep{schlag2021linear}.
However, we believe that it is a distinct concept that is worth clarifying.

\paragraph{Gating.}
Gating originally referred to the gating mechanisms of RNNs such as the LSTM~\citep{lstm} and GRU~\citep{chung2014empirical},
or the gated equation \iftoggle{arxiv}{\eqref{eq:gates}}{} in \cref{thm:gating}.
This was interpreted as a particular mechanism for controlling whether to let an input into the hidden state of an RNN.
In particular, this affects the propagation of signal through time and causes inputs to interact along the sequence length dimension.

However, the concept of gating has since been relaxed in popular usage to simply mean any multiplicative interaction (often with an activation function).
For example, \emph{elementwise} multiplicative components of neural network architectures (that do not interact along sequence length) are now commonly referred to as gated architectures~\citep{hua2022transformer,mehta2023long}, despite a very different meaning than the original RNN sense.
Thus we believe the original concept of \emph{RNN gating} versus the popular usage of \emph{multiplicative gating} actually have a very different semantic meaning.

\paragraph{Hypernetworks.}
Hypernetworks refer to neural networks whose parameters are themselves generated by smaller neural networks.
The original idea~\citep{ha2017hypernetworks} used it in a narrow sense to define a large RNN whose recurrent parameters are generated by a smaller RNN,
and other variants have been around for a long time~\citep{schmidhuber1992learning}.

\paragraph{Data-dependence.}
Similar to hypernetworks, data-dependence can refer to any notion where some parameters of the model depend on the data~\citep{poli2023hyena}.

\paragraph{Example: GLU Activation.}
To illustrate the issues with these concepts, consider a simple diagonal linear layer $y = \bm{D}x$, where $\bm{D}$ is a diagonal weight parameter.
Now suppose that $\bm{D}$ is itself generated from a linear transformation of $x$, with an optional nonlinearity: $\bm{D} = \sigma(\bm{W} x)$.
Since it is diagonal, the multiplication becomes an elementwise product: $y = \sigma(\bm{W} x) \circ x$.

This is a rather trivial transformation, yet it technically satisfies the common meanings of gating (since it has a multiplicative ``branch''),
hypernetworks (since the parameter $\bm{D}$ is generated by another layer), and data-dependent (since $\bm{D}$ depends on the data $x$).
However, this in fact simply defines a GLU function,
which is so simple that it is often considered just an activation function~\citep{dauphin2017language,shazeer2020glu}
instead of a meaningful layer.

\paragraph{Selection.}
Thus, while selection mechanisms could be considered a special case of ideas such as architectural gating, hypernetworks, or data-dependence, so can an enormous range of other constructions---essentially anything with a multiplication, including standard attention mechanisms~\citep{bahdanau2015neural,vaswani2017attention} as well---and we find it uninformative to think of them as such.

Instead, we view it as most closely related to the gating mechanism of traditional RNNs,
which is a special case (\cref{thm:gating}) and also has a deeper history of connections to SSMs through variable (input-dependent) discretization of $\dt$ \citep{funahashi1993approximation,tallec2018can,gu2020hippo}.
We also eschew the term ``gating'' in favor of \emph{selection} to clarify the overloaded use of former.
More narrowly, we use selection to refer to the \emph{mechanistic} action of a model to select or ignore inputs and facilitate data interaction along the sequence length (\cref{sec:method:motivation}).
Beyond selective SSMs and gated RNNs, other examples may include input-dependent convolutions~\citep{yang2019condconv,lioutas2020time,kosma2023time,lutati2023focus} and even attention.




\section{Related Work}
\label{sec:related}

We overview several prior works related to our methods.
We mention that some of the most closely related models include recurrent layers such as S4, S5, and quasi-RNNs;
as well as end-to-end architectures such as H3, RetNet, and RWKV.

\subsection{S4 Variants and Derivatives}

We describe a brief overview of some structured SSMs from past work, particularly those that have a relation to our method.

\begin{itemize}[leftmargin=*,itemsep=0pt,topsep=0pt]
  \item S4~\citep{gu2021combining,gu2022efficiently} introduced the first structured SSM, describing diagonal structure and diagonal plus low-rank (DPLR). It focused on efficient convolutional algorithms for DPLR SSMs due to a connection to continuous-time online memorization (HIPPO)~\citep{gu2020hippo}.
  \item DSS~\citep{gupta2022diagonal} first discovered the empirical effectiveness of diagonal structured SSMs by approximating the HIPPO initialization. This was expanded on theoretically in S4D~\citep{gu2022parameterization}.
  \item S5~\citep{smith2023s5} independently discovered the diagonal SSM approximation, and is the first S4 model to be computed recurrently with the parallel scan. However, this required lowering the effective state dimension, which they accomplished by switching the SSM dimensions from a SISO (single-input single-output) to MIMO (multi-input multi-output) formulation.
    Our proposed S6 shares the scan, but differs by (i) keeping the SISO dimensions, which provides a larger effective recurrent state, (ii) using a hardware-aware algorithm to overcome the computation issue, (iii) adding the selection mechanism.

    \citet{lu2023structured} applied S5 to meta-RL in order to handle resetting the SSM state between episode trajectories.
    Their mechanism can be viewed as a particular hard-coded instance of a selection mechanism,
    where $\dA$ is manually set to $0$, instead of our learnable mechanism that depends on the input.
    It would be interesting to apply selective SSMs generically to this setting and probe if the model has learned to automatically reset its state on episode boundaries.
  \item Mega~\citep{ma2023mega} introduced a simplification of S4 to be real- instead of complex- valued, giving it an interpretation of being an exponential moving average (EMA).
    They additionally make an interesting connection of the discretization step of SSMs to an EMA \emph{damping} term.
    Contrary to findings in the original S4 papers, this was the first model to show that real-valued SSMs are empirically effective in certain settings or when combined with different architectural components.
  \item Liquid S4~\citep{hasani2023liquid} is also motivated by augmenting S4 with an input-dependent state transition. From this perspective it shares similarity to selection mechanisms, although in a limited form which is still computed convolutionally and close to LTI.
  \item SGConv~\citep{li2023makes}, Hyena~\citep{poli2023hyena}, LongConv~\citep{fu2023simple}, MultiresConv~\citep{shi2023sequence}, and Toeplitz Neural Network~\citep{qin2023toeplitz} all focus on the convolutional representation of S4 and create global or long convolution kernels with different parameterizations. However, these methods cannot do fast autoregressive inference directly.
\end{itemize}

Notably, all of these methods, and all other structured SSMs that we are aware of, have been non-selective and usually strictly LTI (linear time invariant).

\subsection{SSM Architectures}

We use SSM architectures or state space neural networks (SSNN) to refer to deep neural network architectures
incorporating one of the previous SSMs as a black box layer.

\begin{itemize}[leftmargin=*,itemsep=0pt,topsep=0pt]
  \item GSS \citep{mehta2023long} was the first gated neural network architecture incorporating SSMs. It is motivated by the gated attention unit (GAU) of \citet{hua2022transformer} and looks quite similar to our block, except with additional projections. Most importantly, its projection \emph{contracts} the model dimension to reduce the state size of the SSM,
    while ours \emph{expands} the model dimension in order to increase the state size, based on the motivation in \cref{sec:method:motivation}.
  \item Mega \citep{ma2023mega} combined the EMA simplification of S4 described above into a hybrid architecture using an efficient attention approximation.
  \item H3~\citep{dao2023hungry} is motivated by combining S4 with linear attention \citep{katharopoulos2020transformers}. It is the first to generalize this formulation of linear attention to more general recurrences, which is also the basis of later architectures.
  \item Selective S4 \citep{wang2023selective} incorporates S4 as a black box to generate a binary mask which is multiplied on the input.
    While sharing the ``selection'' name, we consider this an architectural modification that is closer to architectural gating than a selection mechanism (\cref{sec:discussion:selection}).
    For example, we hypothesize that it would not solve the Selective Copying task because simply masking out the irrelevant inputs does not affect the spacing between the relevant ones (indeed, the Selective Copying task can even be viewed as coming pre-masked if the noise tokens are embedded to 0).
  \item RetNet~\citep{sun2023retentive} is also based on Linear Attention and very similar to H3, but reduces the inner S4 layer to a special case where the state dimension is $N=1$.
    Although not framed as such, its recurrence can be viewed as a special case of a linear SSM.

    Its primary source of improvement is using a linear attention with large \emph{head dimension}, which can be viewed as another method to perform input-dependent state expansion.
    Using a larger head dimension in the context of linear attention variants was first done by H3, but not extensively used since this requires a proportional amount of extra computation.
    RetNet avoids this with an alternate way to parallelize the computation with a variant of standard multi-head attention instead of convolutions, made feasible by their particular special case of SSMs which acts as a simple EMA.
  \item RWKV~\citep{peng2023rwkv} is another recent RNN designed for language modeling. It is based on AFT (attention-free Transformer~\citep{zhai2021attention}), another variant of linear attention. Its main ``WKV'' mechanism involves LTI recurrences and can be seen as the ratio of two SSMs.
\end{itemize}

We also highlight the gated attention unit (GAU) from \citet{hua2022transformer},
which was motivated by combining the Transformer's MHA and MLP blocks together and was an
inspiration for our architecture (\cref{sec:method:architecture}) combining the H3 and MLP blocks.

\subsection{Relationship to RNNs}

RNNs and SSMs are broadly related, as they both involve the concepts of \emph{recurrence} on a latent \emph{state}.


Several older RNNs such as the strongly typed RNN \citep{balduzzi2016strongly}, quasi-RNN (QRNN) \citep{bradbury2016quasi}, and simple recurrent unit (SRU) \citep{lei2017simple,lei2021attention} involve forms of gated RNNs without time-wise nonlinearities.
Because of the connections of gating mechanisms and selection mechanisms, these can be viewed as cases of selective SSMs, and are thus more powerful in a sense than the family of LTI structured SSMs above.
The main differences are:
\begin{itemize}
  \item They do not use state expansion ($N=1$) or selective $\B, \C$ parameters, both of which are important for performance (\cref{sec:exp:ablations}).
  \item They use a heuristic gating mechanism, which we generalize as a consequence of the selection mechanism + discretization (\cref{thm:gating}).
    The connections to principled SSM theory provides better parameterizations and initializations\iftoggle{arxiv}{ (\cref{sec:method:details})}{}.
\end{itemize}

Additionally, older RNNs famously suffered from efficiency issues and the vanishing gradients problem~\citep{hochreiter1991untersuchungen,hochreiter2001gradient,pascanu2013difficulty},
both caused by their sequential nature.
The former could be solved for some of the above RNNs by leveraging the parallel scan~\citep{martin2018parallelizing},
but the latter was difficult without theory later developed for SSMs.
For example, modern structured SSMs differ in more careful parameterization of the recurrent dynamics inspired by classical SSM theory (e.g.\ through discretization~\citep{gu2021combining,gu2023train}), or direct analysis~\citep{orvieto2023resurrecting,kaul2020linear,gupta2022simplifying}).

We also note that there is a long line of work on orthogonal RNNs~\citep{arjovsky2016unitary,henaff2016recurrent,mhammedi2017efficient,vorontsov2017orthogonality,lezcano2019cheap}
which are motivated by constraining the $\dA$ transition matrix to be orthogonal or unitary,
in order to control its eigenvalues and prevent the vanishing gradient problem.
However, these had other limitations; we believe that these stem from the fact that orthogonal/unitary RNNs are also LTI.
For example, they are almost always evaluated on the Copying task which they can solve perfectly, but observed to struggle on the Selective Copying task~\citep{jing2019gated}.

\subsection{Linear Attention}

The Linear Attention (LA)~\citep{katharopoulos2020transformers} framework is an important result popularizing kernel attention and showing how it relates to recurrent autoregressive models.
Many variants have proposed alternative kernels and other modifications.
Random Feature Attention (RFA)~\citep{peng2021random} chooses the kernel feature map to approximate softmax attention (i.e. the $\exp$ feature map) using the random Fourier feature approximation of Gaussian kernels~\citep{rahimi2007random}.
Performer~\citep{choromanski2021rethinking} finds an approximation to the exponential kernel involving only positive features, which also allows the softmax normalization term.
TransNormer~\citep{qin2022devil} showed that the LA denominator term can be unstable and proposed replacing it with a LayerNorm.
cosFormer~\citep{qin2022cosformer} augments RFA with a cosine reweighting mechanism that incorporates positional information to emphasize locality.
Linear Randomized Attention~\citep{zheng2022linear} generalize RFA from the perspective of importance sampling, and generalize it to provide better estimates of the full softmax kernel (rather than just the $\exp$-transformed numerator).

Aside from kernel attention, many other variants of efficient attention exist; the survey \citet{tay2022efficient} offers an extensive categorization of many of these.


\subsection{Long Context Models}

Long context has become a popular subject, and several recent models have claimed to scale to longer and longer sequences.
However, these are often from a computational standpoint and have not been extensively validated.
These include:
\begin{itemize}[leftmargin=*,itemsep=0pt,topsep=0pt]
  \item Recurrent Memory Transformer~\citep{bulatov2023scaling}, a lightweight wrapper around a Transformer backbone. It showed ability to generalize up to 1M sequences but only on synthetic memorization tasks; their main result is similar to our Induction Heads extrapolation experiment (\cref{fig:induction}).
  \item LongNet~\citep{ding2023longnet}, which claimed to scale to 1B length but only evaluated on length $<100K$ for actual tasks.
  \item Hyena and HyenaDNA~\citep{poli2023hyena,nguyen2023hyenadna}, which claimed to leverage up to 1M context. However, their experiments trained on proportionally more data at longer contexts, making it hard to conclude if quality improvements at 1M context are due to context length or due to more data and computation.
  \item Sparse Transformer~\citep{child2019generating} showed a proof-of-concept of using a strided sparse attention Transformer to model audio waveforms of length $2^{20}=1048576$, although did not discuss performance tradeoffs when controlling for computation and model size.
\end{itemize}
In contrast, we believe this work presents one of the first approaches to meaningfully demonstrate increasing performance with longer context.


%

% ========== END CONTENT FROM src/related.tex ==========



% ========== BEGIN CONTENT FROM src/appendix.tex ==========
\section{Mechanics of Selective SSMs}
\label{sec:mechanics}

%

\begin{proof}[Proof of \cref{thm:gating}]
Consider a selective SSM (\cref{alg:s6}) with
$N=1, \A=-1, \B=1, s_\dt=\mathsf{Linear}(x), \tau_\dt=\mathsf{softplus}$.
The corresponding continuous-time SSM \eqref{eq:ssm} is
\begin{align*}%
  h(t) = -h(t) + x(t)
\end{align*}
which is also called a \emph{leaky integrator}.

The discretization step size is
\begin{align*}%
  \dt_t &= \tau_\dt(\mathsf{Parameter} + s_\dt(x_t)) \\
      &= \mathsf{softplus}(\mathsf{Parameter} + \mathsf{Linear}(x_t)) \\
      &= \mathsf{softplus}(\mathsf{Linear}(x_t))
\end{align*}
where we observe that the parameter can be viewed as a learnable bias and folded into the linear projection.

Now applying the zero-order hold (ZOH) discretization formulas:
\begin{align*}%
  \dA_t &= \exp(\dt \A) = \frac{1}{1 + \exp(\mathsf{Linear}(x_t))} = \sigma(-\mathsf{Linear}(x_t))
    \\&= 1 - \sigma(\mathsf{Linear}(x_t))
    \\
  \dB_t &= (\dt \bm{A})^{-1} (\exp(\dt \bm{A}) - \bm{I}) \cdot \dt \bm{B} = -(\exp(\dt \bm{A}) - \bm{I}) = 1 - \dA
    \\&= \sigma(\mathsf{Linear}(x_t))
    .
\end{align*}

Thus the final discrete recurrence \eqref{eq:ssm:recurrence:1} is
\begin{align*}%
  g_t &= \sigma(\mathsf{Linear}(x_t)) \\
  h_{t} &= (1-g_t) h_{t-1} + g_t x_t
\end{align*}
as desired.
\end{proof}

%

\section{Hardware-aware Algorithm For Selective SSMs}
\label{sec:hardware_aware_algo}

Without input-dependent selectivity, SSMs can be efficiently implemented as a
convolution~\citep{gu2022efficiently,dao2023hungry}, which leverages the fast
Fourier transform (FFT) as primitive.
With selectivity, SSMs are no-longer equivalent to convolution, but we leverage
the parallel associative scan.
While SSM scans are theoretically efficient ($O(B L D N)$ FLOPs, scaling linear
in $L$), training foundation models with selective SSMs requires them to be efficient on
modern hardware (GPUs) as well.
We describe how we use \emph{kernel fusion} and \emph{recomputation} to make SSM
scan fast and memory-efficient.
We evaluate the speed of our scan implementation compared to
convolution and attention in \cref{sec:exp:benchmark}, showing that it is up to 7$\times$
times faster than attention at sequence length 32K, and is as memory-efficient
as the best attention implementation (FlashAttention).

\paragraph{Speed.}
On modern hardware accelerators (GPUs) most operations (except matrix multiply)
are bounded by
memory-bandwidth~\citep{williams2009roofline,ivanov2021data,dao2022flashattention}.
This the case with our scan operation, and we use
kernel fusion to reduce the amount of memory IOs, leading to significant speedup
compared to a standard implementation.

The standard way to implement the scan algorithm in \cref{sec:method:selective}
is to prepare the scan input $\dA, \dB$ of size $(B, L, D, N)$ in GPU HBM
(high-bandwidth memory, commonly referred to as GPU memory), call a
parallel associative scan implementation to write the scan output of size
$(B, L, D, N)$ to GPU HBM, then multiply that scan output with $\C$ to
produce an output of size $(B, L, D)$.
However, this requires the number of memory reads/writes on the order of
$O(BLDN)$.
We can instead fuse the discretization step, the scan, and the multiplication
with $\C$ into one kernel:
\begin{enumerate}
  \item We read in $O(BLD + DN)$ bytes of memory ($\dt, \A, \B, \C$) from slow
  HBM to fast SRAM.
  \item We discretize to produce $\dA, \dB$ of size $(B, L, D, N)$ in SRAM.
  \item We perform a parallel associative scan, yielding intermediate states of
  size $(B, L, D, N)$ in SRAM.
  \item We multiply and sum with $\C$, producing outputs of size $(B, L, D)$ and
  write it to HBM.
\end{enumerate}
This way, we reduce IOs by a factor of $O(N)$ (the state dimension), which in
practice speeds up the operation by 20-40 times (\cref{sec:exp:benchmark}).

For sequence length $L$ too long where we cannot fit the sequence in SRAM (which
is much smaller than HBM), we split the sequences into chunks and perform the
fused scan on each chunk. As long as we have the intermediate scan states, we
can continue the scan with the next chunk.

\paragraph{Memory.}
We describe how we use the classical technique of \emph{recomputation} to reduce
the total amount of memory required to train selective SSM layers.

From the way we fuse the forward pass, we do not save the intermediate states of
size $(B, L, D, N)$ to avoid memory blowup.
However, these intermediate states are necessary for the backward pass to
compute gradients.
We instead recompute those intermediate states in the backward pass.
Since the inputs $\dt, \A, \B, \C$ and output gradient read from HBM to SRAM are
of size $O(BLN + DN)$, and the input gradients are also of size $O(BLN + DN)$,
recomputation avoids the cost of reading $O(BLND)$ elements from HBM.
This means that recomputation of the SSM states in the backward pass speeds up
the computation compared to storing them and reading them from HBM.

Beyond optimizing for the memory requirement of just the scan operation, we also
use recomputation to optimize the memory requirement of the entire selective SSM block (input projection,
convolution, activation, scan, output projection).
In particular, we do not save intermediate activations that take a lot of memory
but are fast to recompute (e.g. output of activation function or short
convolution).
As a result, the selective SSM layer has the same memory requirement as an optimized
Transformer implementation with FlashAttention.
In particular, each attention layer (FlashAttention) stores around 12 bytes of
activations per token, an each MLP layer stores around 20 bytes of activations
per token, for a total of 32 bytes ((assuming mixed-precision training in FP16
or BF16)).
Each selective SSM stores around 16 bytes of activations per token.
Hence two layers of selective SSMs have around the same activation memory as an
attention layer and an MLP layer.


\iftoggle{arxiv}{}{
\section{Full Experiments}

\subsection{Synthetic Tasks}
\label{sec:exp-full:synthetic}
\input{src/synthetic}

\subsection{DNA Modeling}
\label{sec:exp-full:genomics}
\input{src/dna}

\input{src/ablations}

\input{src/benchmarks}
}


\section{Experimental Details and Additional Results}
\label{sec:exp-details}


\subsection{Synthetic Tasks}
\label{sec:exp-details:synthetics}

\paragraph{Selective Copying.}

Our setting is on sequences of length 4096, with a vocab size of 16 possible tokens (including the white ``noise'' token from \cref{fig:copying}) and requiring models to memorize 16 ``data'' tokens.
We use 2 layer models with a model dimension of $D = 64$.

Models are trained for 400K steps
at a constant learning rate of $0.0001$
with a batch size of $64$.

\paragraph{Induction Heads.}

\begin{table}
  \footnotesize
  \caption{
    (\textbf{Induction heads}.)
    Models are trained on sequence length $2^8=256$, and tested on various sequence lengths of $2^6=64$ up to $2^{20}=1048576$.
    \cmark\ denotes perfect generalization accuracy, while \xmark\ denotes out of memory.
  }
  \centering
  \begin{tabular}{@{}lllllllllllllllll@{}}
    \toprule
    \sc{Model}       & \sc{Params} & \multicolumn{15}{c}{\sc{Test Accuracy (\%) at Sequence Length}} \\
    \cmidrule(lr){3-17}
                &        & $2^6$  & $2^7$  & $\bm{2^8}$ & $2^9$     & $2^{10}$ & $2^{11}$   & $2^{12}$  & $2^{13}$   & $2^{14}$ & $2^{15}$ & $2^{16}$ & $2^{17}$ & $2^{18}$ & $2^{19}$ & $2^{20}$ \\
    \midrule
    MHA-Abs     & 137K   & \cmark & 99.6   & 100.0      & 58.6      & 26.6     & 18.8       & 9.8       & 10.9       & 7.8      & \xmark   & \xmark   & \xmark   & \xmark   & \xmark   & \xmark \\
    MHA-RoPE    & 137K   & \cmark & \cmark & 100.0        & 83.6      & 31.3     & 18.4       & 8.6       & 9.0        & 5.5      & \xmark   & \xmark   & \xmark   & \xmark   & \xmark   & \xmark \\
    MHA-xPos    & 137K   & \cmark & \cmark & 100.0      & 99.6      & 67.6     & 25.4       & 7.0       & 9.0        & 7.8      & \xmark   & \xmark   & \xmark   & \xmark   & \xmark   & \xmark \\
    H3          & 153K   & \cmark & \cmark & 100.0      & 80.9      & 39.5     & 23.8       & 14.8      & 8.2        & 5.9      & 6.6      & 8.2      & 4.7      & 8.2      & 6.3      & 7.4 \\
    Hyena       & 69M$^*$    & 97.7   & \cmark & 100.0      & \cmark    & 44.1     & 12.5       & 6.6       & 5.1        & 7.0      & 5.9      & 6.6      & 6.6      & 5.9      & 6.3      & 9.8 \\
    Mamba       & 74K    & \cmark & \cmark & 100.0      & \cmark    & \cmark   & \cmark     & \cmark    & \cmark     & \cmark   & \cmark   & \cmark   & \cmark   & \cmark   & \cmark   & \cmark \\
    \bottomrule
    \multicolumn{17}{l}{\begin{tabular}{@{}l@{}}\footnotesize{$^*$ Most of the parameters are in learnable positional encodings.}\end{tabular}}
  \end{tabular}
  \label{tab:induction}
\end{table}


Training consists of randomly generating data every step, with a batch size of $8$.
We choose an ``epoch'' size of 8192 steps, and track the accuracy on fixed validation sets (also randomly generated) of each target sequence length. %
For the MHA-Abs and Mamba models, results are reported after the 25th epoch ($8192 \times 25 = 204800$ steps).
For the MHA-RoPE and MHA-xPos models, results are reported after the 50th epoch ($8192 \times 50 = 409600$ steps).
For the LTI H3 and Hyena models, results are reported after the 10th epoch ($81920$ steps) because they had converged by then and failed to improve further.

We use the Adam optimizer with no weight decay.
All models are trained at constant learning rates $2e-4$ and $1e-3$,
and the better results are reported for each model ($2e-4$ for all models except Mamba).
The attention and Hyena models did not learn at LR $1e-3$.
H3 learned at both LRs, but interestingly generalized better to shorter sequences at the smaller LR of $2e-4$.
Mamba learned at both LRs, but extrapolated better at the larger LR of $1e-3$.


\subsection{Language Modeling}
\label{sec:exp-details:lm}


\subsubsection{Scaling Law Details}
\label{sec:exp-details:lm:scaling}

Scaling law experiments generally followed the GPT3 recipe.
All models were trained on the Pile with the GPT2 tokenizer.

\paragraph{Model Sizes.}

\cref{tab:gpt3} specifies the model sizes we use for scaling laws.
This is taken directly from the GPT3 specifications~\citep{brown2020language},
with very minor modifications.
First, we changed the batch size of the 1.3B model from 1M tokens to 0.5M tokens, since we did not use enough parallelization to require the larger batch size.
Second, we changed the number of training steps and total tokens to roughly match Chinchilla scaling laws~\citep{hoffmann2022empirical}, which specify that training tokens should increase proportionally to model size.

\begin{table}
  \caption{
    (\textbf{Scaling Law Model Sizes}.)
    Our model sizes and hyperparameters for scaling experiments.
    (Model dimension and number of heads applies only to Transformer models.)
  }
  \centering
  \small
  \begin{tabular}{@{}llllllll@{}}
    \toprule
    \sc{Params} & $\mathtt{n\_layers}$ & $\mathtt{d\_model}$ & $\mathtt{n\_heads}$ / $\mathtt{d\_head}$ & \sc{Training steps}  & \sc{Learning Rate}  & \sc{Batch Size} & \sc{Tokens} \\
    \midrule
    125M   & 12                   & 768                 & 12 / 64                                  & 4800            & 6e-4           & 0.5M tokens & 2.5B       \\
    350M   & 24                   & 1024                & 16 / 64                                  & 13500           & 3e-4           & 0.5M tokens & 7B         \\
    760M   & 24                   & 1536                & 16 / 96                                  & 29000           & 2.5e-4         & 0.5M tokens & 15B       \\
    1.3B   & 24                   & 2048                & 32 / 64                                  & 50000           & 2e-4           & 0.5M tokens & 26B       \\
    \bottomrule
  \end{tabular}
  \label{tab:gpt3}
\end{table}

\paragraph{Training Recipes.}

All models used the AdamW optimizer with
\begin{itemize}
  \item gradient clip value $1.0$
  \item weight decay $0.1$
  \item no dropout
  \item linear learning rate warmup with cosine decay
\end{itemize}
By default, the peak learning rate is the GPT3 specification.

We give several models an ``improved recipe'', inspired by changes adopted by popular large language models such as PaLM~\citep{chowdhery2022palm} and LLaMa~\citep{touvron2023llama}.
These include:
\begin{itemize}
  \item linear learning rate warmup with cosine decay to $1e-5$, with a peak value of $5\times$ the GPT3 value
  \item no linear bias terms
  \item RMSNorm instead of LayerNorm
  \item AdamW hyperparameter $\beta=(.9, .95)$ (the GPT3 value) instead of the PyTorch default of $\beta=(.9, .999)$
\end{itemize}

\paragraph{Architecture and Training Details.}

Our models are:
\begin{itemize}[leftmargin=*,itemsep=0pt]
  \item \textbf{Transformer}: The standard Transformer based on GPT3 (\cref{tab:gpt3}).
  \item \textbf{Transformer++}: A Transformer with an improved architecture, namely rotary positional encodings \citep{su2021roformer} and SwiGLU MLP~\citep{shazeer2020glu}, and the improved training recipe above.
  \item \textbf{Hyena}: Interleaving a Hyena block (the H3 block with S4 replaced by a global convolution parameterized by an MLP) with standard MLP blocks.
    The MLP blocks have expansion factor $2$ instead of $4$ and the number of layers is correspondingly increased by $1.5\times$ to preserve parameter count.
  \item \textbf{H3++}: The H3 architecture with a few modifications, including (i) using the same ``thin'' Hyena dimensions above (ii) the improved training recipe above (iii) a linear attention \emph{head dimension} of 8.
  \item \textbf{RWKV}: The default RWKV model from \citet{peng2023rwkv}, including its modified MLP block. We also used as much of its specified training recipe as possible, such as increasing the learning rates by $2\times$ or $3\times$ on certain parameters.
  \item \textbf{RetNet}: The default RetNet model from~\citet{sun2023retentive}. We also gave it the improved training recipe above.
  \item \textbf{Mamba}: The standard Mamba architecture, with the improved training recipe.
\end{itemize}

\subsubsection{Additional Scaling Law Ablations}
\label{sec:exp-details:lm:scaling-ablations}

We perform additional ablations on the architecture using the same protocol as the 2k context length scaling laws in \cref{fig:lm-scaling} (\emph{Left}).

\paragraph{Mamba Architecture: Interleaving Blocks.}

We test the effect of different architectural blocks combined with the Mamba block.
We focus on the viewpoint that the Mamba block is simply the standard SwiGLU block with an extra $\mathsf{conv} \to \mathsf{SSM}$ path added.
This leads to two natural ablations:
\begin{itemize}[leftmargin=*,itemsep=0pt]
  \item What if the Mamba block is interleaved with a standard MLP block, instead of stacked homogenously? This can also be interpreted as taking Mamba and removing half of the SSMs.
  \item What if the Mamba block is interleaved with MHA (multi-head attention) blocks? This can also be interpreted as taking a Transformer with SwiGLU MLPs (i.e.\ what we call Transformer++) and simply adding SSMs to the MLP blocks.
\end{itemize}

\cref{fig:lm-scaling-ablations} (\emph{Right}) shows these variants compared to the original (homogenous) Mamba architecture.
Interestingly, neither change matters too much.
The Mamba-MLP architecture is only slightly worse, and still better than all models except Transformer++.
The Mamba-MHA architecture is only slightly better, which is somewhat surprising in light of the fact that many recent works
have found that combining (LTI) SSMs with Attention can lead to substantial improvements~\citep{dao2023hungry,fathullah2023multi,saon2023diagonal,zuo2022efficient,fathi2023block}.


\paragraph{H3 Architecture: Training Recipes.}

Next we ablate differences between the Hyena and H3++ models, our weakest and strongest models outside of Transformer++ and Mamba,
particularly to isolate the effect of training recipes.

\begin{itemize}[leftmargin=*,itemsep=0pt]
  \item \textbf{Hyena}: The Hyena block with its original architecture and GPT3 training recipe (same as \cref{fig:lm-scaling}).
  \item \textbf{Hyena+}: The same architecture but with the improved training recipe described above.
  \item \textbf{H3+}: The same architecture as Hyena+ but with the Hyena convolution kernel swapped out for S4D convolution kernel.
  \item \textbf{H3++}: The same as H3+, but with a linear attention \emph{head dimension} of 8. This increases computation inside the SSM recurrence but does not increase parameters.
\end{itemize}

Our general convention is that ``Model+'' represents the base model with the improved training recipe,
and ``Model++'' also allows for architectural changes.

\cref{fig:lm-scaling-ablations} (\emph{Right}) shows that
\begin{itemize}[leftmargin=*,itemsep=0pt]
  \item A large improvement is achieved by the improved training recipe, which was used for many of the models in the main \cref{fig:lm-scaling} (RetNet, H3++, Transformer++, Mamba).
  \item The choice of the inner LTI SSM does not matter (e.g.\ Hyena vs.\ S4), consistent with findings throughout this paper.
  \item The head dimension expansion improves performance, consistent with one of our main themes that expanded state dimension improves performance for SSMs (\cref{sec:method}).
\end{itemize}


\begin{figure}[!t]
  \centering
  \begin{subfigure}[t]{0.49\linewidth}
    \centering
    \includegraphics[width=\textwidth]{fig/pile_2k_ablations_mamba.pdf}
  \end{subfigure}
  \begin{subfigure}[t]{0.49\linewidth}
    \centering
    \includegraphics[width=\textwidth]{fig/pile_2k_ablations_h3.pdf}
  \end{subfigure}
  \caption{
    (\textbf{Scaling laws: extra ablations}.) %
    (\emph{Left}) Instead of 
    (\emph{Right}) Instead of 
  }
  \label{fig:lm-scaling-ablations}
\end{figure}

%

%

\subsubsection{Downstream Evaluation Details}

This pretraining procedure is the same as the scaling law protocol, but extended to 300B tokens and with the GPT-NeoX tokenizer~\citep{black2022gpt} instead of GPT2 tokenizer.
For the 1.3B model, we use a batch size of 1M tokens to be consistent with the GPT3 specifications.
We report the perplexity on the Pile validation set, and for this metric only compare to models trained on the same dataset and with the same tokenizer, in particular Pythia and RWKV.

For downstream evaluation, we use the LM evaluation harness from EleutherAI~\citep{eval-harness}, as done by most work in this area.
We evaluate on the following tasks/datasets that measure common sense reasoning:
\begin{itemize}
  \item LAMBADA~\citep{paperno2016lambada}
  \item HellaSwag~\citep{zellers2019hellaswag}
  \item PIQA~\citep{bisk2020piqa}
  \item ARC-challenge~\citep{clark2018think}
  \item ARC-easy: an easy subset of ARC-challenge
  \item WinoGrande~\citep{sakaguchi2021winogrande}
\end{itemize}

We report accuracy for LAMBADA, WinoGrande, PIQA, and ARC-easy, and accuracy normalized by sequence length for HellaSwag and ARC-challenge (since normalized accuracy is higher for almost all models for these task).

\subsection{DNA Modeling}

\subsubsection{Pretraining Details}

We describe the dataset and training procedure of the HG38 pretraining task in more detail.

The dataset follows the splits from the prior Enformer work on genomics~\citep{avsec2021effective}; the training split contains a total of $S=34021$ segments of length $2^{17}=131072$ that cover the genome,
for a total of approximately 4.5 billion tokens (DNA base pairs).
These segments are pairs of (chromosome number, starting index, ending index), and can be extended if necessary (e.g.\ to get longer segments).

We deviate from HyenaDNA when the training sequence length is not $2^{17}$.
HyenaDNA always takes a fixed sub-segment (e.g. the beginning or middle of the prescribed segment), and thus for any training sequence length each epoch is fixed to $34021$ samples and doesn't necessarily go through the whole genome.
On the other hand, we use the entire training data:
\begin{itemize}[leftmargin=*,topsep=0pt]
  \item When the context length $L$ is less than (or equal to) $2^{17}$, we divide up each segment into non-overlapping sub-segments of length $L$, so that there are $S \times \frac{2^{17}}{L}$ total samples and $S \times 2^{17} \approx 4.5B$ tokens per epoch.
  \item When the context length $L$ is greater than $2^{17}$, we turn each segment into two samples, one that begins with the prescribed segment and one that ends with the prescribed segment. Thus each epoch has $2S$ items and $2SL$ tokens per epoch. For example, at sequence length $2^{18}=262144$ there are $4\times$ as many tokens as the default, and at sequence length $2^{20}$ there are $16\times$ as many tokens.
\end{itemize}


Other training details generally follow the same protocol as our language modeling experiments (\cref{sec:exp-details:lm}).
For example, we use the AdamW with $(\beta_1, \beta_2) = (0.9, 0.95)$, no dropout, weight decay $0.1$.
We use a cosine learning rate scheduler with linear warmup for 10\% of total steps.

\subsubsection{Scaling: Model Size Details}

\paragraph{Models.}
The models we consider are:
\begin{itemize}[leftmargin=*,itemsep=0pt]
  \item Transformer++: a Transformer with improved architecture, notably the usage of RoPE positional encodings~\citep{su2021roformer}. Informally, we found these to be noticeably better than vanilla positional encodings from~\citep{vaswani2017attention}.
  \item HyenaDNA: the Hyena model from \citet{poli2023hyena,nguyen2023hyenadna}, which is roughly a Transformer with the MHA block replaced by an H3 block using a global convolution parameterized by an MLP.
  \item Mamba: the standard Mamba architecture.
\end{itemize}

\paragraph{Model Sizes.}
We use the following model sizes.
\begin{center}
  \begin{tabular}{@{}llllllll@{}}
    \toprule
    \sc{Blocks} & 4 & 5 & 6 & 7 & 8 & 10 & 12 \\
    \sc{Model Dimension} & 64 & 96 & 128 & 192 & 256 & 384 & 512 \\
    \sc{Params (Approx.)} & 250K & 700K & 1.4M & 3.5M & 7.0M & 19.3M & 40.7M \\
    \bottomrule
  \end{tabular}
\end{center}
Note that the number of blocks for Mamba is doubled, because one Transformer ``layer'' includes both the MHA and MLP blocks (and similarly for Hyena),
which requires two Mamba blocks to match parameters (\cref{sec:method:architecture}).

\paragraph{Training.}
For each model (Transformer++, HyenaDNA, Mamba), we swept the learning rate across $\{1e-3, 2e-3, 4e-3, 8e-3\}$.
The optimal Transformer and HyenaDNA learning rates were 2e-3 across all sizes.
The optimal Mamba learning rate was 8e-3; note that Mamba performed better than baselines with matched learning rates (2e-3),
but was more stable and improved even more at higher learning rates.
(Furthermore, as this LR is on the upper range of the sweep, it is possible that our results are still suboptimal.)

Note that, in contrast to standard LM scaling laws (\cref{tab:gpt3}), our LR held constant across model sizes for simplicity.
The optimal LR should go down for larger models, but we didn't find a noticeable effect at the small model sizes (at most a few million parameters) we considered.

\subsubsection{Scaling: Context Length Details}

We use a total batch size of $2^{24}\approx 16M$ tokens per training step, for every sequence length (e.g.\ at length $2^{20}$ there are $16$ segments per batch and at length $2^{10}$ there are $16384$ segments per batch).
This is a large batch size relative to the model size by usual LM standards, but
note that a batch size of $2^{23}$ is the minimum possible on a machine with 8 GPUs and sequence length of $2^20$,
and that HyenaDNA used much larger batches of $2^{28}$.

The learning rate used was $0.008$ for Mamba and 0.001 for HyenaDNA;
we initially attempted to use the same learning rate of $0.002$ from the previous section for HyenaDNA, but found that it was unstable at the longest context length.

\paragraph{Sequence Length Warmup.}
Following~\citep{nguyen2023hyenadna}, we use sequence length warmup (SLW) during pretraining.
We choose a simple schedule of 2 epochs at each power-of-two sequence length starting from $2^{10}=1024$.
(Note that because of how data is curated, at the longest sequence lengths more steps and tokens are spent proportionally.
In particular, each stage up to length $2^{17}$ processes the same number of tokens,
but $4\times$ as many tokens are processed at length $2^{18}$, $8\times$ as many at length $2^{19}$, and $16\times$ as many at length $2^{20}$.)

Unlike HyenaDNA, we always control for the number of tokens per gradient update,
so the batch size is successively halved as the sequence lengths are doubled in each stage.

\begin{remark}
  We also note that the schedule was not tuned, and we never experimented with turning off sequence length warmup for these pretraining experiments.
  We later found that SLW did not help noticeably for audio pretraining at similar lengths (\cref{sec:exp:audio}), and it is possible that it is not necessary for DNA pretraining either.
\end{remark}

\subsubsection{Species (Great Apes) Classification}

Models are causal and therefore only the last element (across the sequence length) of the model's output is used for the classification head.
Note that we control for the total number of elements in the loss function per gradient step.
The pretraining objective includes all positions across the sequence length,
so that $\mathtt{batch\_size} \times \mathtt{sequence\_length}$ is held constant; in other words, the batch size decreases as the sequence length increases.
However, for a classification task, since only the last position enters the loss,
the batch size itself is held constant.
Note that this also means that fine-tuning models with longer sequence lengths is more computationally expensive.

Training consists of 10 epochs, each of which has 1024 gradient steps.
Each gradient step uses batch size 64, which are all independently randomly drawn by uniformly picking a species, uniformly picking a chromosome, and then uniformly picking a contiguous segment of DNA.

Following~\citep{nguyen2023hyenadna}, models with a maximum context length greater than $2^{14} = 16384$ use sequence length warmup with 1 epoch at length $2^{14}=16384$, 1 epoch at length $2^{15}=32768$, 1 epoch at length $2^{16}=65536$, and so on up to the maximum sequence length.
For example, the model with $2^{20}=1048576$ context undergoes $6$ epochs of sequence length warmup before $4$ more epochs at its maximum sequence length.

The learning rate for all Hyena models is $\mathtt{4e-5}$,
while the learning rate for all Mamba models is $\mathtt{1e-4}$.
These were found by performing learning rate sweeps for each model among $\{1e-5, 2e-5, 4e-5, 1e-4, 2e-4\}$ for the smaller sequence lengths $(2^{10}, 2^{12}, 2^{14}, 2^{16})$,
and these values were consistently found to be the best for each model.
An abridged learning rate sweep was done at length $2^{18}$, which agreed with these values,
and a single run at length $2^{20}$ was performed (as described above, the computational cost of these experiments is proportional to the sequence length).
The learning rate followed a cosine decay schedule with warmup with 5 epochs of linear warmup to the maximum learning rate, and 5 epochs of cosine decay down to $1e-6$.
The unusually long learning rate warmup schedule was chosen because the sequence length warmup was also long (e.g.\ comprising 6 out of 10 epochs for the model with context length $2^{20}$); we did not experiment with this choice.

Results for the Species classification task are in \cref{tab:species}.

\begin{table}[!t]
  \caption{
    (\textbf{Great Apes DNA Classification}.)
    Accuracy after fine-tuning on sequences of length $2^{10}=1024$ up to $2^{20}=1048576$ using pretrained models of the same context length.
    Random guessing is 20\%.
  }
  \centering
  \begin{tabular}{@{}llllllll@{}}
    \toprule
    \sc{Model}         & \sc{Params}    & \multicolumn{6}{c}{\sc{Accuracy (\%) at Sequence Length}} \\
    \cmidrule(lr){3-8}
                       &                & $2^{10}$ & $2^{12}$ & $2^{14}$ & $2^{16}$ & $2^{18}$ & $2^{20}$ \\
    \midrule
    HyenaDNA           & 1.4M           & 28.04    & 28.43    & 41.17    & 42.22    & 31.10    & 54.87 \\
    Mamba              & 1.4M           & 31.47    & 27.50    & 27.66    & 40.72    & 42.41    & \textbf{71.67} \\
    \midrule
    Mamba              &  7M            & 30.00    & 29.01    & 31.48    & 43.73    & 56.60    & \textbf{81.31} \\
    \bottomrule
  \end{tabular}
  \label{tab:species}
\end{table}


\subsection{Audio Details}
\label{sec:exp-details:audio}

%

\subsubsection{YouTubeMix Audio Pretraining}

%

%

%


\paragraph{Model.}
We use a model with 3 blocks per stage ($3\times5=15$ total Mamba blocks), pooling factor $p=16$, and outer dimension $D=64$, for about 3.5M parameters.

\paragraph{Dataset.}
The data is mu-law encoded at 8 bits, so the model is modeling discrete tokens with a vocab size of $256$.

%
The dataset consists of clips of up to 1 minute long, or length $960000$,
which is subsampled and divided into segments of any desired sequence length.
Since the architecture involves two stages of pooling by a factor of $16$,
and we want the resulting sequence length to be a a multiple of $8$ for hardware efficiency,
the longest possible sequence is $468 \times 2048 = 958464$.
The rest of our sequence lengths are defined by successively halving this and rounding up to the nearest multiple of $2048$.

\cref{tab:youtubemix-lengths} lists the specifications used in \cref{fig:youtubemix}.
Beyond the varying batch sizes, the number of valid segments in the training set varied
between different sequence lengths (e.g.\ the number of training steps per epoch was not constant for different points in the graph), which may have contributed to kinks in the scaling curves.

\begin{table}[!t]
  \caption{YouTubeMix length scaling sequence lengths and batch sizes.}
  \centering
  \begin{tabular}{@{}rll@{}}
    \toprule
    \sc{Sequence length} & \sc{Batch size} & \sc{Tokens / batch} \\
    \midrule
    $468 \times 2048 = 958464$ & $1$ & $958464$ \\
    $234 \times 2048 = 479232$ & $2$ & $958464$ \\
    $117 \times 2048 = 239616$ & $4$ & $958464$ \\
    $59 \times 2048 = 120832$ & $8$ & $966656$ \\
    $30 \times 2048 = 61440$ & $16$ & $983040$ \\
    $15 \times 2048 = 30720$ & $32$ & $983040$ \\
    $8 \times 2048 = 16384$ & $64$ & $1048576$ \\
    $4 \times 2048 = 8192$ & $128$ & $1048576$ \\
    \bottomrule
  \end{tabular}
  \label{tab:youtubemix-lengths}
\end{table}

\paragraph{Training.}
Models were trained for $200K$ training steps with a maximum learning rate of $0.002$,
$20K$ (10\%) warmup steps, and weight decay $0.1$ (similar to our general pretraining recipe across domains).

\paragraph{Additional Ablations: SSM Parameterizations.}

We investigate SSM parameterizations on long-form audio waveform pretraining in the setting of \cref{fig:youtubemix}.
The setting is modified slightly to use larger models ($8$ layers and $D=64$ for 6M params, the SaShiMi default),
shorter sequences ($2^{11}=2048$ to $2^{18}=262144$ instead of $2^{13}$ to $2^{20}$), lower LR ($0.001$ from $0.002$),
and shorter training cycles (100K instead of 200K steps).

\cref{fig:youtubemix-ablations} shows that the change from S4 $\to$ S6 (i.e.\ the selection mechanism) is not always beneficial.
On long-form audio waveforms, it in fact significantly hampers performance, which may be intuitive from the point of view that audio is uniformly sampled and very smooth,
and therefore benefits from continuous linear time-invariant (LTI) methods.
After ablating away the selection mechanism, note that the resulting model is the S4 layer inside the Mamba block.
To disambiguate, we call this Mamba-S4 as opposed the default Mamba architecture Mamba-S6.

However, on the right side, we keep the outer layers of the U-Net Mamba-S4 and ablate only the inner layers.
The performance differences shrink dramatically; this reinforces the hypothesis that layers closer to the \emph{raw} audio signal should be LTI,
but once they are ``tokenized'' and compressed by the outer layers, the inner layers no longer need to be LTI.
In this setting however, the real-valued SSM still underperforms the complex-valued one.

\begin{figure}
  \begin{minipage}[t]{.49\linewidth}
    \centering
    \includegraphics[width=\linewidth]{fig/youtubemix_ablations.pdf}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{.49\linewidth}
    \centering
    \includegraphics[width=\linewidth]{fig/youtubemix_ablations_center.pdf}
  \end{minipage}
  \captionsetup{type=figure}
  \caption{
    (\textbf{Audio Pretraining (YouTubeMix) Ablations}.)
    As a uniformly-sampled ``continuous'' signal modality, audio waveforms actually benefit from LTI models which have matching inductive bias.
    (\emph{Left}) Homogenous models (all blocks have the same parameterization)
    (\emph{Right}) Only the center U-Net blocks are ablated; the outer blocks are Mamba-S4. Purple line is same as figure on left.
  }
  \label{fig:youtubemix-ablations}
\end{figure}

\subsubsection{SC09 Speech Generation}

Autoregressive training largely followed the autoregressive language modeling protocol, such as
\begin{itemize}
  \item Weight decay $0.1$
  \item Learning rate warmup for 10\% of total steps
  \item AdamW optimizer with $\beta=(0.9, 0.95)$
  \item Gradient clip value $0.1$
\end{itemize}
We used a learning rate of $0.002$ and $200000$ training steps at a batch size of $16$.

The large Mamba model in \cref{tab:sc09} has 15 layers per stage with an outer dimension of $D=96$ and pooling factor $4$.
We note that this dataset is small (training went through 100 epochs) and for this large model, there was significant overfitting of the BPB or NLL. However, automated metrics of generated samples continually improving throughout training.

The models in the architecture ablations in \cref{tab:sc09-ablations}
all have 8 layers per stage with an outer dimension of $\mathtt{D}=64$ and pooling factor $4$.
The S4+MLP block has roughly $2D^2 + 4D^2$ parameters (expansion factor $2$ in the MLP).
The Transformer block has $4D^2 + 2D^2$ parameters (expansion factor $1$ in the MLP).
The Mamba block has the usual $\approx 6D^2$ parameters.
All models have roughly 6M total parameters.


\subsection{Efficiency Benchmark}
\label{sec:exp-details:benchmark}

\paragraph{Scan Operation.}
We compare the core operation of selective SSMs, which is the parallel scan (\cref{sec:method:scan}), against convolution and attention, measured on an A100 80GB PCIe GPU.
Note that these do not include the cost of other operations outside of this core operation, such as computing the convolutional kernel in global-convolution models, or computing the QKV projections in attention.

As a baseline, we implement a standard parallel scan in PyTorch with no kernel fusion. This requires materializing the parameters $\dA, \dB, \C$ in HBM.

Our scan implementation fuses the discretization step and the parallel scan, avoiding the cost of materializing all the large parameters in HBM.

For convolution, we use the standard implementation in PyTorch, which separately performs FFTs on the inputs and the filters, multiply them in frequency domain, then performs an inverse FFT to obtain the result. The theoretical complexity is $O(L \log (L))$ for sequence length $L$.

For attention, we compare against the fastest implementation that we are aware of (FlashAttention-2~\citep{dao2023flashattention2}), with causal mask. Note that FlashAttention-2 with causal mask is about 1.7$\times$ faster than without causal mask, since approximately only half of the attention entries are computed.

We use batch size of 1 and increase the sequence length from $2^9=512$, $2^{10}\approx 1K$, $2^{11}\approx 2K$, up to $2^{19} \approx 500K$ (some of the baselines run out of memory before reaching 500K). 
We use a model dimension of $D = 1024$ and state dimension $N = 16$.
We measure with BF16 inputs, which is the data type most commonly used for large scale training. 

\paragraph{End-to-end Inference.} We measure the inference throughput of a Mamba 1.4B model and an untrained Mamba 6.9B model, against a standard Transformer (GPT3 architecture) at 1.3B and 6.7B size.
We use the standard Transformer implementation in the Huggingface \texttt{transformers} library. 

We set the prompt length to be 2048 and the generation length to be 128. We vary the batch size from 1, 2, 4, 8, 16, 32, 64, to 128, and measure time time taken to generate 128 tokens. We then calculate the throughput (tokens/s) as $\text{batch size} \times 128 / \text{time taken}$.
We repeat the measurements 3 times and take the average.
Measurements are done on an A100 80GB PCIe GPU.

\paragraph{Memory Benchmark.}

The memory usage simply scales proportionally to the size of the activation tensors, as with most deep sequence models. We report measurements of the training memory requirements of 125M models on 1 A100 80GB GPU. Each batch consists of sequences of length 2048. We compare to the most memory-efficient Transformer implementation we are aware of (with kernel fusion from \texttt{torch.compile} and with FlashAttention-2).
\cref{tab:memory} shows that Mamba's memory requirement is comparable to a similar-sized Transformer with an extremely optimized implementation, and we expect further improvement in Mamba's memory footprint in the future.

\begin{table}
  \caption{(\textbf{Memory benchmark}.) Mamba's memory footprint is comparable to the most optimized Transformer. Results for 125M models.}
  \centering
  \begin{tabular}{@{}lll@{}}
    \toprule
    Batch size & Transformer (w/ FlashAttention-2) & Mamba  \\
    \midrule
    1          & 4.6GB                             & 4.8GB  \\
    2          & 5.2GB                             & 5.8GB  \\
    4          & 6.9GB                             & 7.3GB  \\
    8          & 11.5GB                            & 12.3GB \\
    16         & 20.7GB                            & 23.1GB \\
    32         & 34.5GB                            & 38.2GB \\
    \bottomrule
  \end{tabular}
  \label{tab:memory}
\end{table}



% ========== END CONTENT FROM src/appendix.tex ==========



\end{document}
